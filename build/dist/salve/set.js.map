{"version":3,"file":"set.js","sourceRoot":"","sources":["../../../lib/salve/set.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;;AAEH;;;;;;GAMG;AACH,SAAgB,KAAK,CAAI,EAAU,EAAE,CAAS;IAC5C,KAAK,MAAM,CAAC,IAAI,CAAC,EAAE;QACjB,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KACX;AACH,CAAC;AAJD,sBAIC;AAED;;;;;;;;;GASG;AACH,SAAgB,MAAM,CAAI,EAAU,EACV,CACsB;IAC9C,MAAM,GAAG,GAAW,IAAK,EAAE,CAAC,WAA0B,EAAE,CAAC;IACzD,sEAAsE;IACtE,2DAA2D;IAC3D,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;QAClB,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,EAAE;YACrB,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SACZ;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAdD,wBAcC;AAED;;;;;;;;;;;GAWG;AACH,SAAgB,GAAG,CAAI,EAAU,EACV,CACsB;IAC3C,MAAM,GAAG,GAAW,IAAK,EAAE,CAAC,WAA0B,EAAE,CAAC;IACzD,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;QAClB,MAAM,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC;QACjC,IAAI,MAAM,KAAK,SAAS,EAAE;YACxB,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;SACjB;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAbD,kBAaC;AAED,uEAAuE","sourcesContent":["/**\n * Set utilities.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n * @private\n */\n\n/**\n * Add the elements of another set to this set. This mutates this set.\n *\n * @param me The set to mutate.\n *\n * @param s The set to add.\n */\nexport function union<T>(me: Set<T>, s: Set<T>): void {\n  for (const x of s) {\n    me.add(x);\n  }\n}\n\n/**\n * Selects a subset of values.\n *\n * @param me The set to filter.\n *\n * @param f A function that selects values.\n *\n * @returns An object of the same class as the object on which the method is\n * called. This object contains only the value selected by the function.\n */\nexport function filter<T>(me: Set<T>,\n                          f: (value: T, index: number,\n                              me: Set<T>) => any): Set<T> {\n  const ret: Set<T> = new (me.constructor as typeof Set)();\n  // The fat arrow is used to prevent a caller from accessing ``this.b``\n  // through the 3rd parameter that would be passed to ``f``.\n  let index = 0;\n  for (const x of me) {\n    if (f(x, index++, me)) {\n      ret.add(x);\n    }\n  }\n\n  return ret;\n}\n\n/**\n * This method works like Array.map but with a provision for eliminating\n * elements.\n *\n * @param me The set to map.\n *\n * @param f This parameter plays the same role as for ``Array``'s ``map``\n * method.  However, when it returns an undefined value, this return value is\n * not added to set that will be returned.\n *\n * @returns The new set. This set is of the same class as the original set.\n */\nexport function map<T>(me: Set<T>,\n                       f: (value: T, index: number,\n                           me: Set<T>) => any): Set<T> {\n  const ret: Set<T> = new (me.constructor as typeof Set)();\n  let index = 0;\n  for (const x of me) {\n    const result = f(x, index++, me);\n    if (result !== undefined) {\n      ret.add(result);\n    }\n  }\n\n  return ret;\n}\n\n//  LocalWords:  param NaiveSet Mangalam MPL Dubeau HashSet hashstructs\n"]}