{"version":3,"file":"step16.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/step16.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Simplification step 16.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element, isElement } from \"../parser\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport { findDescendantsByLocalName, removeUnreferencedDefs } from \"./util\";\n\n// Elements that cannot contain references.\nconst skip = new Set([\"name\", \"anyName\", \"nsName\", \"param\", \"empty\",\n                      \"text\", \"value\", \"notAllowed\", \"ref\"]);\n\ninterface RemovedDefineState {\n  topElement: Element;\n\n  used: boolean;\n}\n\ninterface State {\n  removedDefines: Map<string, RemovedDefineState>;\n  seenRefs: Set<string>;\n}\n\nfunction wrapElements(state: State, root: Element): Element[] {\n  let elementCount = 0;\n  const { seenRefs } = state;\n  const toAppend = [];\n  for (const el of findDescendantsByLocalName(root, \"element\")) {\n    elementCount++;\n\n    // If an element is not appearing in a define element, then create one for\n    // it.\n    // tslint:disable-next-line:no-non-null-assertion\n    if (el.parent!.local !== \"define\") {\n      // The first child of an ``element`` element is a name class but not\n      // necessarily ``name``.\n      const first = el.children[0] as Element;\n      const elName = first.local === \"name\" ? first.text : \"\";\n      // Note that elName in the following string is not necessary to guarantee\n      // uniqueness. It is a convenience that allows recognizing names more\n      // easily. So the value ``\"\"`` used when we don't have a name element does\n      // not harm the uniqueness of the name.\n      const name = `__${elName}-elt-${elementCount}`;\n\n      const ref = Element.makeElement(\"ref\", []);\n      ref.setAttribute(\"name\", name);\n      el.parent!.replaceChildWith(el, ref);\n      seenRefs.add(name);\n      const defEl = Element.makeElement(\"define\", [el]);\n      toAppend.push(defEl);\n      defEl.setAttribute(\"name\", name);\n    }\n  }\n\n  return toAppend;\n}\n\nfunction removeDefsWithoutElement(state: State, el: Element): void {\n  // A define which does not contain an ``element`` child is going to be\n  // removed. Any reference to it will have to be replaced with the content of\n  // the ``define``.\n  const removedDefines = state.removedDefines;\n  const children = el.children;\n  // We always keep ``start``.\n  const keep = [children[0]];\n  // The el parameter is the grammar. By this stage, it has a ``start`` element\n  // as its first child, and ``define`` elements for the remainder of its\n  // children.\n  for (let ix = 1; ix < children.length; ++ix) {\n    const child = children[ix] as Element;\n    // Define elements by this time have a single child, which is an\n    // element (but may not be an ``element`` element).\n    const topElement = child.children[0] as Element;\n    if (topElement.local === \"element\") {\n      keep.push(child);\n      continue;\n    }\n\n    child.removeChildAt(0); // Remove topElement from child.\n    removedDefines.set(child.mustGetAttribute(\"name\"),\n                       { topElement, used: false });\n  }\n\n  el.replaceContent(keep);\n}\n\n/**\n * Substitute ``ref`` elements that point to ``define`` elements that have been\n * removed due to not containing a top-level ``element`` with the content of the\n * referred define.\n *\n * @param state The transformation state.\n *\n * @param el The element to process.\n *\n * @returns A replacement for the element, which may be equal to ``el`` if there\n * is no replacement.\n */\nfunction substituteRefs(state: State, el: Element,\n                        seenNames: Set<string>): Element {\n  const local = el.local;\n\n  let ret = el;\n  if (local === \"ref\") {\n    // If a reference is to a definition that does not contain an element\n    // element as the top element, move the definition in place of the ref.\n    const name = el.mustGetAttribute(\"name\");\n    if (seenNames.has(name)) {\n      throw new SchemaValidationError(\n        `circularity on the definition named ${name}`);\n    }\n    const def = state.removedDefines.get(name);\n    if (def === undefined) {\n      // We are keeping this reference, so mark it as seen. Otherwise, we're\n      // going to remove it, and we don't need to mark it.\n      state.seenRefs.add(name);\n    }\n    else {\n      // If the definition was used, clone it to allow for multiple copies of\n      // the definition's content to be put into the tree if it is references\n      // multiple times.\n      if (def.used) {\n        ret = def.topElement.clone();\n      }\n      else {\n        // Walk the element we're about to put into the tree. We walk it only\n        // once, and record the result of walking it.\n\n        const newNames = new Set(seenNames);\n        newNames.add(name);\n        def.topElement = ret = substituteRefs(state, def.topElement, newNames);\n        def.used = true;\n      }\n    }\n  }\n  else if (!skip.has(local)) {\n    //\n    // By this point, the majority of elements have at most two children.\n    // (<grammar> is the exception.)\n    //\n    // Due to the !skip.has(local) test above, first, and second are Element\n    // object, if they exists. So we assert instead of testing.\n    //\n    const [first, second] = el.children as [Element, Element];\n    if (first !== undefined) {\n      const sub1 = substituteRefs(state, first, seenNames);\n      if (first !== sub1) {\n        el.replaceChildAt(0, sub1);\n      }\n\n      if (second !== undefined) {\n        const sub2 = substituteRefs(state, second, seenNames);\n        if (second !== sub2) {\n          el.replaceChildAt(1, sub2);\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Implements step 16 of the XSL pipeline. Namely:\n *\n * - All ``element`` elements that are not wrapped in a ``define`` element are\n *   wrapped in new ``define`` elements. And a ``ref`` element takes the\n *   place of the original ``element`` and refers to the new ``define``.\n *\n * - ``ref`` elements that reference a ``define`` which does not contain an\n *   ``element`` element as the top element are replaced by the contents of the\n *   ``define`` element they reference.\n *\n * - Remove ``define`` elements that are not referenced.\n *\n * @param tree The tree to process. It is modified in-place.\n *\n * @returns The new root of the tree.\n */\nexport function step16(tree: Element): Element {\n  const currentTree = tree;\n  if (currentTree.local !== \"grammar\") {\n    throw new Error(\"must be called with a grammar element\");\n  }\n\n  const state: State = {\n     // By this point the top element must be the only grammar in the tree.\n    removedDefines: new Map(),\n    seenRefs: new Set(),\n  };\n\n  // The specification is not super clear about this, but we have to perform the\n  // wrapping of ``element`` in ``define`` before starting with ref substitution\n  // because ref subsitution is liable to get into an infinite loop where\n  // ``define/@name=\"x\"`` contains a ``ref/@name=\"x\"``. By doing the element\n  // wrapping first, we eliminate those cases that are valid Relax NG. Any\n  // remaining ``define`` which is without a top-level ``element`` and is\n  // self-referential is invalid.\n  const toAppend = wrapElements(state, currentTree);\n  // We wait until appending the new definitions so that the following operation\n  // does not have to scan through them needlessly. The new definitions contain\n  // ``element`` as their top pattern so they cannot be removed.\n  removeDefsWithoutElement(state, currentTree);\n  currentTree.appendChildren(toAppend);\n  const seenNames = new Set<string>();\n  const { children } = currentTree;\n  for (let ix = 0; ix < children.length; ++ix) {\n    const child = children[ix];\n    if (!isElement(child)) {\n      continue;\n    }\n\n    const substitute = substituteRefs(state, child, seenNames);\n    if (child !== substitute) {\n      currentTree.replaceChildAt(ix, substitute);\n    }\n  }\n\n  removeUnreferencedDefs(currentTree, state.seenRefs);\n\n  return currentTree;\n}\n"]}