{"version":3,"file":"step17.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/step17.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Simplification step 17.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"../parser\";\nimport { removeUnreferencedDefs } from \"./util\";\n\n// These are elements that cannot contain notAllowed and cannot contain\n// references.\nconst skip = new Set([\"name\", \"anyName\", \"nsName\", \"param\", \"empty\",\n                      \"text\", \"value\", \"notAllowed\", \"ref\"]);\n\nfunction walk(el: Element, ix: number, refs: Set<string>): void {\n  const { local, children } = el;\n\n  // Skip those elements that are empty or that cannot contain notAllowed.\n  if (children.length === 0 || skip.has(local)) {\n    return;\n  }\n\n  // Since we walk the children first, all the transformations that pertain to\n  // the children are applied before we deal with the parent, and there should\n  // not be any need to process the tree multiple times.\n\n  // At this stage of processing, most elements contain at most two\n  // children. And due to the skip.has(local) test above, these children must be\n  // Element objects. (<grammar> is the exception.)\n  let [first, second] = children as [Element, Element];\n  walk(first, 0, refs);\n  if (second !== undefined) {\n    walk(second, 1, refs);\n  }\n\n  // Elements may be removed by the above walks.\n  if (children.length === 0) {\n    return;\n  }\n\n  // Reacquire.\n  ([first, second] = children as [Element, Element]);\n\n  const firstNA = first.local === \"notAllowed\";\n  const secondNA = second !== undefined && second.local === \"notAllowed\";\n\n  if (firstNA || secondNA) {\n    // tslint:disable-next-line:no-non-null-assertion\n    const parent = el.parent!;\n    // We used to have a map from which we'd get a handler to call but that\n    // method is not faster than this switch.\n    switch (local) {\n      case \"choice\":\n        if (firstNA && secondNA) {\n          // A choice with two notAllowed is replaced with notAllowed.\n          parent.replaceChildAt(ix, Element.makeElement(\"notAllowed\", []));\n        }\n        else {\n          // A choice with exactly one notAllowed is replaced with the other\n          // child of the choice.\n          parent.replaceChildAt(ix, firstNA ? second : first);\n        }\n        return;\n      case \"group\":\n      case \"oneOrMore\":\n      case \"interleave\":\n      case \"attribute\":\n      case \"list\":\n        // An attribute (or list, group, interleave, oneOrMore) with at least\n        // one notAllowed is replaced with notAllowed.\n        parent.replaceChildAt(ix, Element.makeElement(\"notAllowed\", []));\n        return;\n      case \"except\":\n        // An except with notAllowed is removed.\n        parent!.removeChildAt(ix);\n        return;\n      default:\n    }\n  }\n\n  if (first.local === \"ref\") {\n    refs.add(first.mustGetAttribute(\"name\"));\n  }\n\n  if (second !== undefined && second.local === \"ref\") {\n    refs.add(second.mustGetAttribute(\"name\"));\n  }\n}\n\n/**\n * Implements step 17 of the XSL pipeline. Namely:\n *\n * - All ``attribute``, ``list``, ``group``, ``interleave``, and ``oneOrMore``\n *   elements having a ``notAllowed`` child are replaced with a ``notAllowed``\n *   element.\n *\n * - A ``choice`` element with two ``notAllowed`` children is replaced with a\n *   ``notAllowed`` element.\n *\n * - A ``choice`` element with a single ``notAllowed`` child is replaced with\n *   the other child.\n *\n * - An ``except`` element with a ``notAllowed`` child is removed.\n *\n * These transformations are repeated until they no longer modify the tree. (The\n * way we apply the transformations obviates the need to repeat them.)\n *\n * Any ``define`` element that becomes unreachable after transformation is\n * removed.\n *\n * @param tree The tree to process. It is modified in-place.\n *\n * @returns The new root of the tree.\n */\nexport function step17(tree: Element): Element {\n  const refs: Set<string> = new Set();\n\n  // The top element is necessarily <grammar>, and it has only element children.\n  let ix = 0;\n  for (const child of tree.children) {\n    walk(child as Element, ix++, refs);\n  }\n\n  removeUnreferencedDefs(tree, refs);\n\n  return tree;\n}\n"]}