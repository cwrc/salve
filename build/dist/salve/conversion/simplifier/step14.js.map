{"version":3,"file":"step14.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/step14.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Simplification step 14.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"../parser\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport { findChildrenByLocalName, findDescendantsByLocalName, getName,\n         groupBy } from \"./util\";\n\nfunction makeName(el: Element): string {\n  let ret = el.local;\n\n  if (ret === \"def\") {\n    ret += `@name=\"${getName(el)}\"`;\n  }\n\n  return ret;\n}\n\nfunction combine(els: Element[]): void {\n  if (els.length < 2) {\n    // There's nothing to actually *combine*.\n\n    if (els.length > 0) {\n      // Delete the useless combine attribute that may be present.\n      els[0].removeAttribute(\"combine\");\n    }\n\n    return;\n  }\n\n  let undefinedCombine = false;\n  let combineAs: string | undefined;\n\n  for (const el of els) {\n    const combineAttr = el.getAttribute(\"combine\");\n\n    if (combineAttr === undefined) {\n      if (undefinedCombine) {\n        throw new SchemaValidationError(\n          `more than one ${makeName(el)} without @combine`);\n      }\n      undefinedCombine = true;\n    }\n    else {\n      if (combineAs === undefined) {\n        combineAs = combineAttr;\n      }\n      else if (combineAs !== combineAttr) {\n        throw new SchemaValidationError(\n          `inconsistent values on ${makeName(el)}/@combine`);\n      }\n    }\n  }\n\n  if (combineAs === undefined) {\n    throw new Error(\"no combination value found\");\n  }\n\n  let wrapper = Element.makeElement(combineAs, []);\n  const [first, second, ...rest] = els;\n  wrapper.grabChildren(first);\n  wrapper.grabChildren(second);\n  second.parent!.removeChild(second);\n\n  for (const el of rest) {\n    const newWrapper = Element.makeElement(combineAs, [wrapper]);\n    newWrapper.grabChildren(el);\n    el.parent!.removeChild(el);\n    wrapper = newWrapper;\n  }\n\n  first.appendChild(wrapper);\n  first.removeAttribute(\"combine\");\n}\n\n/**\n * Implements step 14 of the XSL pipeline. Namely, in each grammar:\n *\n * - ``start`` elements are combined.\n *\n * - ``define`` elements with the same name are combined.\n *\n * The scope of the transformation performed for a grammar include all ``start``\n * and ``define`` elements, *excluding* those that may be in a descendant\n * ``grammar`` element.\n *\n * @param el The tree to process. It is modified in-place.\n *\n * @returns The new root of the tree.\n */\nexport function step14(el: Element): Element {\n  const grammars = findDescendantsByLocalName(el, \"grammar\");\n  if (el.local === \"grammar\") {\n    grammars.unshift(el);\n  }\n\n  for (const grammar of grammars) {\n    combine(findChildrenByLocalName(grammar, \"start\"));\n    const defs = findChildrenByLocalName(grammar, \"define\");\n    const grouped = groupBy(defs, getName);\n\n    for (const group of grouped.values()) {\n      combine(group);\n    }\n  }\n\n  return el;\n}\n"]}