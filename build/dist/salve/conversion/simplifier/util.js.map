{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utilities for simplification support for trees produced by the parser module.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element, isElement } from \"../parser\";\n\n// tslint:disable-next-line:no-http-string\nexport const RELAXNG_URI = \"http://relaxng.org/ns/structure/1.0\";\n// tslint:disable-next-line:no-http-string\nexport const ANNOS_URI = \"http://relaxng.org/ns/compatibility/annotations/1.0\";\n// tslint:disable-next-line:no-http-string\nexport const XHTML_URI = \"http://www.w3.org/1999/xhtml\";\n\nexport function findChildrenByLocalName(el: Element,\n                                        name: string): Element[] {\n  return el\n    .children\n    .filter(child => isElement(child) && child.local === name) as Element[];\n}\n\nexport function findDescendantsByLocalName(el: Element,\n                                           name: string): Element[] {\n  const ret: Element[] = [];\n  _findDescendantsByLocalName(el, name, ret);\n\n  return ret;\n}\n\nexport function _findDescendantsByLocalName(el: Element,\n                                            name: string,\n                                            ret: Element[]): void {\n  for (const child of el.children) {\n    if (!isElement(child)) {\n      continue;\n    }\n\n    if (child.local === name) {\n      ret.push(child);\n    }\n\n    _findDescendantsByLocalName(child, name, ret);\n  }\n}\n\nexport function findMultiDescendantsByLocalName(el: Element,\n                                                names: string[]):\nRecord<string, Element[]> {\n  const ret: Record<string, Element[]> = Object.create(null);\n  for (const name of names) {\n    ret[name] = [];\n  }\n\n  _findMultiDescendantsByLocalName(el, names, ret);\n\n  return ret;\n}\n\nfunction _findMultiDescendantsByLocalName(el: Element,\n                                          names: string[],\n                                          ret: Record<string, Element[]>):\nvoid {\n  for (const child of el.children) {\n    if (!isElement(child)) {\n      continue;\n    }\n\n    const name = child.local;\n    if (names.includes(name)) {\n      ret[name].push(child);\n    }\n\n    _findMultiDescendantsByLocalName(child, names, ret);\n  }\n}\n\n/**\n * This is a specialized version of [[findMultiDescendantsByLocalName]] that\n * searches through the first child element and its descendants. ``element`` and\n * ``attribute`` elements during simplification get their name class recorded as\n * their first child element.\n *\n * @param el The element in which to search.\n *\n * @param names The name class elements to look for.\n *\n * @returns A map of name to element list.\n */\nexport function findMultiNames(el: Element,\n                               names: string[]): Record<string, Element[]> {\n  const nameClass = el.children[0] as Element;\n  const descendants = findMultiDescendantsByLocalName(nameClass, names);\n\n  const name = nameClass.local;\n  if (names.includes(name)) {\n    if (!(name in descendants)) {\n      descendants[name] = [nameClass];\n    }\n    else {\n      descendants[name].unshift(nameClass);\n    }\n  }\n\n  return descendants;\n}\n\n/**\n * Index the elements of ``arr`` by the keys obtained through calling\n * ``makeKey``. If two elements resolve to the same key, the later element\n * overwrites the earlier.\n *\n * @param arr The array to index.\n *\n * @param makeKey A function that takes an array element and makes a key by\n * which this element will be indexed.\n *\n * @return The indexed elements.\n */\nexport function indexBy<T>(arr: T[],\n                           makeKey: (x: T) => string): Map<string, T> {\n  const ret = new Map<string, T>();\n  for (const x of arr) {\n    ret.set(makeKey(x), x);\n  }\n\n  return ret;\n}\n\n/**\n * Group the elements of ``arr`` by the keys obtained through calling\n * ``makeKey``. Contrarily to [[indexBy]], this function allows for multiple\n * elements with the same key to coexist in the results because the resulting\n * object maps keys to arrays of elements rather than keys to single elements.\n *\n * @param arr The array to index.\n *\n * @param makeKey A function that takes an array element and makes a key by\n * which this element will be indexed.\n *\n * @return The grouped elements.\n */\nexport function groupBy<T>(arr: T[],\n                           makeKey: (x: T) => string): Map<string, T[]> {\n  const ret = new Map<string, T[]>();\n  for (const x of arr) {\n    const key = makeKey(x);\n    let list = ret.get(key);\n    if (list === undefined) {\n      list = [];\n      ret.set(key, list);\n    }\n\n    list.push(x);\n  }\n\n  return ret;\n}\n\n/**\n * Get the value of the @name attribute.\n *\n * @param el The element to process.\n */\nexport function getName(el: Element): string {\n  return el.mustGetAttribute(\"name\");\n}\n\n/**\n * Removes unreferenced ``define`` elements from a grammar.\n *\n * **Important**: this is a very ad-hoc function, not meant for general\n * consumption. For one thing, this function works only if called with ``el``\n * pointing to a top-level ``grammar`` element **after** all ``grammar``\n * elements have been reduced to a single ``grammar``, all ``define`` elements\n * moved to that single ``grammar``, and ``grammar`` contains ``start`` as the\n * first element, and the rest of the children are all ``define`` elements.\n *\n * This function does no check these constraints!!! You must call it from a\n * stage where these constraints hold.\n *\n * This function does not guard against misuse. It must be called from steps\n * that execute after the above assumption holds.\n *\n * @param el The element that contains the ``define`` elements.\n *\n * @param seen A set of ``define`` names. If the name is in the set, then there\n * was a reference to the name, and the ``define`` is kept. Otherwise, the\n * ``define`` is removed.\n */\nexport function removeUnreferencedDefs(el: Element, seen: Set<string>): void {\n  const children = el.children as Element[];\n  for (let ix = 1; ix < children.length; ++ix) {\n    if (seen.has(children[ix].mustGetAttribute(\"name\"))) {\n      continue;\n    }\n\n    el.removeChildAt(ix);\n    --ix;\n  }\n}\n"]}