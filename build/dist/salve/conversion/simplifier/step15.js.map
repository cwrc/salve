{"version":3,"file":"step15.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/step15.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Simplification step 15.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element, isElement } from \"../parser\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport { RELAXNG_URI } from \"./util\";\n\nclass GrammarNode {\n  readonly childGrammars: GrammarNode[] = [];\n  readonly defines: Element[] = [];\n  readonly refs: Element[] = [];\n  readonly parentRefs: Element[] = [];\n  readonly refNames: Set<string> = new Set();\n  readonly parentRefNames: Set<string> = new Set();\n  readonly defineNames: Set<string> = new Set();\n\n  constructor(readonly id: number, readonly grammar: Element) {}\n}\n\ninterface State {\n  latestId: number;\n  root: GrammarNode | null;\n  stack: GrammarNode[];\n}\n\nfunction gatherGrammars(el: Element, state: State): void {\n  const { local } = el;\n\n  const { stack } = state;\n  const top = stack[stack.length - 1];\n  let pop = false;\n  switch (local) {\n    case \"ref\":\n      top.refs.push(el);\n      top.refNames.add(el.mustGetAttribute(\"name\"));\n      break;\n    case \"define\":\n      top.defines.push(el);\n      top.defineNames.add(el.mustGetAttribute(\"name\"));\n      break;\n    case \"grammar\":\n      pop = true;\n      const thisGrammar = new GrammarNode(++state.latestId, el);\n      stack.push(thisGrammar);\n      if (top !== undefined) {\n        top.childGrammars.push(thisGrammar);\n      }\n      break;\n    case \"parentRef\":\n      top.parentRefs.push(el);\n      top.parentRefNames.add(el.mustGetAttribute(\"name\"));\n      break;\n    default:\n      if (state.root === null) {\n        stack.push(new GrammarNode(++state.latestId, el));\n        pop = true;\n      }\n  }\n\n  if (state.root === null) {\n    // We have to acquire it from stack[0] and not from the variable top.\n    state.root = stack[0];\n  }\n\n  for (const child of el.children) {\n    if (!isElement(child)) {\n      continue;\n    }\n\n    gatherGrammars(child, state);\n  }\n\n  if (pop) {\n    stack.pop();\n  }\n}\n\nfunction transformGrammars(multiple: boolean,\n                           root: GrammarNode,\n                           parent: GrammarNode | null,\n                           grammar: GrammarNode): void {\n  for (const name of grammar.refNames) {\n    if (!grammar.defineNames.has(name)) {\n      throw new SchemaValidationError(`dangling ref: ${name}`);\n    }\n  }\n\n  if (parent === null && grammar.parentRefNames.size !== 0) {\n    throw new SchemaValidationError(\"top-level grammar contains parentRef!\");\n  }\n\n  for (const name of grammar.parentRefNames) {\n    // The test above ensures parent is not null.\n    // tslint:disable-next-line:no-non-null-assertion\n    if (!parent!.defineNames.has(name)) {\n      throw new SchemaValidationError(`dangling parentRef: ${name}`);\n    }\n  }\n\n  const toRename =\n    grammar.defines.concat(grammar.refs,\n                           ...grammar.childGrammars.map(x => x.parentRefs));\n\n  const suffix = `-gr-${grammar.id}`;\n  // Make all names unique globally.\n  for (const el of toRename) {\n    el.setAttribute(\"name\", el.mustGetAttribute(\"name\") + suffix);\n  }\n\n  // Move the ``define`` elements to the root grammar. We do this on the root\n  // grammar too so that the ``define`` elements are moved after ``start``.\n  root.grammar.appendChildren(grammar.defines);\n\n  for (const child of grammar.childGrammars) {\n    transformGrammars(multiple, root, grammar, child);\n  }\n\n  // Rename all parentRef elements to ref elements.\n  for (const parentRef of grammar.parentRefs) {\n    parentRef.local = \"ref\";\n  }\n\n  const start = grammar.grammar.children[0] as Element;\n  if (start.local !== \"start\") {\n    throw new Error(\"there should be a single start element in the grammar!\");\n  }\n\n  if (grammar !== root) {\n    // Remove the remaining ``grammar`` and ``start`` elements.\n    grammar.grammar.parent!.replaceChildWith(grammar.grammar,\n                                             start.children[0] as Element);\n  }\n\n}\n\n/**\n * Implements step 15 of the XSL pipeline. Namely:\n *\n * - Rename each ``define`` element so as to make it unique across the\n *   schema. We do this by giving a unique id to each ``grammar`` element, which\n *   is the number of ``grammar`` elements before it, in document reading order,\n *   plus 1. Then we add to ``define/@name`` the string ``-gr-{id}`` where\n *   ``{id}`` is the grammar's id of the grammar to which the ``define``\n *   belongs. NOTE: this pattern was selected to avoid a clash with step 16,\n *   which creates new ``define`` elements.\n *\n * - Rename each ``ref`` and ``parentRef`` to preserve the references the\n *   establish to ``define`` elements.\n *\n * - Create a top level ``grammar/start`` structure, if necessary.\n *\n * - Move all ``define`` elements to the top ``grammar``.\n *\n * - Rename all ``parentRef`` elements to ``ref``.\n *\n * - Replace all ``grammar/start`` elements with the expression contained\n *   therein, except for the top level ``grammar/start``.\n *\n * @param el The tree to process. It is modified in-place.\n *\n * @returns The new tree root.\n */\nexport function step15(el: Element): Element {\n  let root = el;\n\n  if (el.local !== \"grammar\") {\n    root = Element.makeElement(\"grammar\", [Element.makeElement(\"start\", [el])]);\n\n    root.setXMLNS(RELAXNG_URI);\n    el.removeAttribute(\"xmlns\");\n  }\n\n  const state: State = {\n    latestId: 0,\n    root: null,\n    stack: [],\n  };\n\n  gatherGrammars(root, state);\n\n  const multiple = state.latestId !== 1;\n\n  // tslint:disable-next-line:no-non-null-assertion\n  const grammar = state.root!;\n  if (multiple) {\n    transformGrammars(multiple, grammar, null, grammar);\n  }\n  else {\n    // If we have only a single grammar, we can reduce the work to this.\n    for (const name of grammar.refNames) {\n      if (!grammar.defineNames.has(name)) {\n        throw new SchemaValidationError(`dangling ref: ${name}`);\n      }\n    }\n\n    if (grammar.parentRefNames.size !== 0) {\n      throw new SchemaValidationError(\"top-level grammar contains parentRef!\");\n    }\n\n    let start = grammar.grammar.children[0] as Element;\n    if (start.local !== \"start\") {\n      // The first element is not start. Move the defines around.\n      grammar.grammar.appendChildren(grammar.defines);\n\n      start = grammar.grammar.children[0] as Element;\n      if (start.local !== \"start\") {\n        // Somehow it did not work!\n        throw new Error(\"there should be a single start element in the \\\ngrammar!\");\n      }\n    }\n  }\n\n  return root;\n}\n"]}