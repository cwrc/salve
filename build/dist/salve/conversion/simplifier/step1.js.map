{"version":3,"file":"step1.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/simplifier/step1.ts"],"names":[],"mappings":";;;;AAAA;;;;;GAKG;AACH,sCAAqD;AACrD,4DAA6D;AAC7D,iCACiC;AAIjC,SAAgB,UAAU,CAAC,IAAS,EAAE,IAAY;IAChD,OAAO,IAAI,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;AACxC,CAAC;AAFD,gCAEC;AAKD,SAAe,eAAe,CAAC,WAAgB,EAChB,QAAkB,EAClB,EAAW,EACX,KAAa;;QAE1C,MAAM,QAAQ,GAAG,UAAU,CAAC,WAAW,EAAE,EAAE,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;QACtE,IAAI,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE;YAC1C,MAAM,IAAI,yCAAqB,CAAC;EAClC,QAAQ,CAAC,OAAO,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC5D;QAED,OAAO,EAAE,IAAI,EAAE,MAAM,KAAK,CAAC,QAAQ,CAAC,EAAE,QAAQ,EAAE,CAAC;IACnD,CAAC;CAAA;AAED,MAAM,KAAK;IACT,YAA6B,MAAc;QAAd,WAAM,GAAN,MAAM,CAAQ;IAAG,CAAC;IAEzC,IAAI,CAAC,UAAe,EAAE,QAAkB,EACnC,EAAW;;YACpB,0EAA0E;YAC1E,kEAAkE;YAElE,oDAAoD;YACpD,EAAE,CAAC,MAAM,GAAG,EAAE,CAAC;YAEf,iEAAiE;YACjE,0EAA0E;YAC1E,uEAAuE;YACvE,MAAM,KAAK,GAAG,EAAE,CAAC,gBAAgB,EAAE,CAAC;YACpC,IAAI,QAA4B,CAAC;YACjC,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACrC,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;gBACzB,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;gBAC7B,IAAI,IAAI,KAAK,OAAO,IAAI,GAAG,KAAK,EAAE,IAAI,MAAM,KAAK,OAAO,EAAE;oBACxD,IAAI,IAAI,KAAK,UAAU,EAAE;wBACvB,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;qBACvB;oBACD,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC;iBACpB;qBACI,IAAI,IAAI,KAAK,MAAM;oBACf,IAAI,KAAK,MAAM;oBACf,IAAI,KAAK,SAAS,EAAE;oBAC3B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;iBAChC;aACF;YAED,MAAM,WAAW,GAAG,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;gBACvD,UAAU,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YACnC,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC;YAC/B,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACzB,mDAAmD;gBACnD,IAAI,KAAK,KAAK,OAAO,IAAI,KAAK,KAAK,OAAO,EAAE;oBAC1C,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;wBAC5B,IAAI,kBAAS,CAAC,KAAK,CAAC,EAAE;4BACpB,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;yBAC/C;qBACF;iBACF;qBACI;oBACH,MAAM,WAAW,GAAG,EAAE,CAAC;oBACvB,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;wBAC5B,IAAI,kBAAS,CAAC,KAAK,CAAC,EAAE;4BACpB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;4BAC9D,WAAW,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;4BACrD,SAAS;yBACV;wBAED,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;wBACxB,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;wBAC1B,IAAI,KAAK,KAAK,EAAE,EAAE;4BAChB,8BAA8B;4BAC9B,WAAW,CAAC,IAAI,CAAC,KAAK,KAAK,MAAM,IAAI,IAAI,KAAK,KAAK,CAAC,CAAC;gCACpC,sBAAsB;gCACtB,IAAI,aAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gCACjB,KAAK,CAAC,CAAC;yBACzB;wBACD,wDAAwD;qBACzD;oBAED,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;iBAChC;aACF;YAED,MAAM,OAAO,GAAI,IAA2C,CAAC,KAAK,CAAC,CAAC;YACpE,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,OAAO,EAAE,CAAC;aACX;YAED,MAAM,WAAW,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;YACxE,OAAO,WAAW,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC;QACjD,CAAC;KAAA;IAEK,WAAW,CAAC,WAAgB,EAAE,QAAkB,EACpC,EAAW;;YAC3B,wCAAwC;YACxC,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,GAClC,MAAM,eAAe,CAAC,WAAW,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAChE,YAAY,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,EACR,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,GAAG,QAAQ,CAAC,EAClC,YAAY,CAAC,CAAC;YAC7C,MAAM,EAAE,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACjC,MAAM,MAAM,GAAG,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAC/C,IAAI,EAAE,KAAK,SAAS,IAAI,MAAM,KAAK,SAAS,EAAE;gBAC5C,YAAY,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;aACrC;YAED,yEAAyE;YACzE,0BAA0B;YAC1B,IAAI,YAAY,CAAC,YAAY,CAAC,iBAAiB,CAAC,KAAK,SAAS,EAAE;gBAC9D,YAAY,CAAC,YAAY,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC;aAClD;YAED,qEAAqE;YACrE,WAAW;YACX,IAAI,EAAE,CAAC,MAAM,KAAK,SAAS,EAAE;gBAC3B,yEAAyE;gBACzE,yEAAyE;gBACzE,6CAA6C;gBAC7C,YAAY,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;gBAEtC,EAAE,CAAC,MAAO,CAAC,gBAAgB,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;aAC/C;YAED,OAAO,YAAY,CAAC;QACtB,CAAC;KAAA;IAEK,OAAO,CAAC,WAAgB,EAAE,QAAkB,EACpC,EAAW;;YACvB,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,GACpC,MAAM,eAAe,CAAC,WAAW,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAChE,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,GAAG,QAAQ,CAAC,EAC5C,YAAY,CAAC,CAAC;YAE9B,yEAAyE;YACzE,yCAAyC;YACzC,YAAY,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI,YAAY,CAAC,KAAK,KAAK,SAAS,EAAE;gBACpC,MAAM,IAAI,yCAAqB,CAAC,uCAAuC;oBACvC,oCAAoC,CAAC,CAAC;aACvE;YAED,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,GACjD,sCAA+B,CAAC,EAAE,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;YAC3D,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,GACjD,sCAA+B,CAAC,YAAY,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;YACrE,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC9B,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC9B,MAAM,IAAI,yCAAqB,CAC7B,qDAAqD,CAAC,CAAC;iBAC1D;gBACD,KAAK,MAAM,KAAK,IAAI,aAAa,EAAE;oBACjC,KAAK,CAAC,MAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;iBAClC;aACF;YAED,MAAM,cAAc,GAAG,cAAO,CAAC,WAAW,EAAE,cAAO,CAAC,CAAC;YACrD,MAAM,cAAc,GAAG,cAAO,CAAC,WAAW,EAAE,cAAO,CAAC,CAAC;YAErD,KAAK,MAAM,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE,EAAE;gBACvC,MAAM,IAAI,GAAG,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAErC,IAAI,IAAI,KAAK,SAAS,EAAE;oBACtB,MAAM,IAAI,yCAAqB,CAC7B,gCAAgC,IAAI;QACtC,CAAC,CAAC;iBACH;gBAED,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;oBACtB,GAAG,CAAC,MAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;iBAC9B;aACF;YACD,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC;YACjB,EAAE,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;YAC3B,YAAY,CAAC,KAAK,GAAG,KAAK,CAAC;YAE3B,EAAE;YACF,2EAA2E;YAC3E,mEAAmE;YACnE,0EAA0E;YAC1E,2EAA2E;YAC3E,4EAA4E;YAC5E,6BAA6B;YAC7B,EAAE;YACF,yEAAyE;YACzE,wEAAwE;YACxE,EAAE;YACF,2EAA2E;YAC3E,4EAA4E;YAC5E,4EAA4E;YAC5E,qCAAqC;YACrC,EAAE;YACF,IAAI,YAAY,CAAC,YAAY,CAAC,iBAAiB,CAAC,KAAK,SAAS,EAAE;gBAC9D,YAAY,CAAC,YAAY,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC;aAClD;YACD,wEAAwE;YACxE,0BAA0B;YAC1B,EAAE,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;YAE9B,OAAO,IAAI,CAAC;QACd,CAAC;KAAA;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,SAAsB,KAAK,CAAC,YAAiB,EACjB,IAAa,EACb,MAAc;;QACxC,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;IAC/E,CAAC;CAAA;AAJD,sBAIC","sourcesContent":["/**\n * Simplification step 1.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element, isElement, Text } from \"../parser\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport { findMultiDescendantsByLocalName, getName, groupBy,\n         indexBy } from \"./util\";\n\nexport type Parser = (filePath: URL) => Promise<Element>;\n\nexport function resolveURL(base: URL, tail: string): URL {\n  return new URL(tail, base.toString());\n}\n\ntype Handler = (parentBase: URL, seenURLs: string[],\n                el: Element) => Promise<Element | null>;\n\nasync function loadFromElement(currentBase: URL,\n                               seenURLs: string[],\n                               el: Element,\n                               parse: Parser): Promise<{ tree: Element;\n                                                         resolved: URL; }> {\n  const resolved = resolveURL(currentBase, el.mustGetAttribute(\"href\"));\n  if (seenURLs.includes(resolved.toString())) {\n    throw new SchemaValidationError(`detected an import loop: \\\n${seenURLs.reverse().concat(resolved.toString()).join(\"\\n\")}`);\n  }\n\n  return { tree: await parse(resolved), resolved };\n}\n\nclass Step1 {\n  constructor(private readonly parser: Parser) {}\n\n  async walk(parentBase: URL, seenURLs: string[],\n             el: Element): Promise<Element> {\n    // The XML parser we use immediately drops all *elements* which are not in\n    // the RELAXNG_URI namespace so we don't have to remove them here.\n\n    // We move all RNG nodes into the default namespace.\n    el.prefix = \"\";\n\n    // At this point it is safe to drop all the attributes in the XML\n    // namespace. \"xml:base\" in particular is no longer of any use. We do keep\n    // namespace declarations, as they are used later for resolving QNames.\n    const attrs = el.getRawAttributes();\n    let baseAttr: string | undefined;\n    for (const name of Object.keys(attrs)) {\n      const attr = attrs[name];\n      const { uri, prefix } = attr;\n      if (name !== \"xmlns\" && uri !== \"\" && prefix !== \"xmlns\") {\n        if (name === \"xml:base\") {\n          baseAttr = attr.value;\n        }\n        delete attrs[name];\n      }\n      else if (name === \"name\" ||\n               name === \"type\" ||\n               name === \"combine\") {\n        attr.value = attr.value.trim();\n      }\n    }\n\n    const currentBase = baseAttr === undefined ? parentBase :\n      resolveURL(parentBase, baseAttr);\n    const { children, local } = el;\n    if (children.length !== 0) {\n      // We don't normalize text nodes in param or value.\n      if (local === \"param\" || local === \"value\") {\n        for (const child of children) {\n          if (isElement(child)) {\n            await this.walk(currentBase, seenURLs, child);\n          }\n        }\n      }\n      else {\n        const newChildren = [];\n        for (const child of children) {\n          if (isElement(child)) {\n            const replace = await this.walk(currentBase, seenURLs, child);\n            newChildren.push(replace === null ? child : replace);\n            continue;\n          }\n\n          const orig = child.text;\n          const clean = orig.trim();\n          if (clean !== \"\") {\n            // name gets the trimmed value\n            newChildren.push(local === \"name\" && orig !== clean ?\n                             // We're triming text.\n                             new Text(clean) :\n                             child);\n          }\n          // else we drop a node consisting entirely of whitespace\n        }\n\n        el.replaceContent(newChildren);\n      }\n    }\n\n    const handler = (this as unknown as Record<string, Handler>)[local];\n    if (handler === undefined) {\n      return el;\n    }\n\n    const replacement = await handler.call(this, currentBase, seenURLs, el);\n    return replacement === null ? el : replacement;\n  }\n\n  async externalRef(currentBase: URL, seenURLs: string[],\n                    el: Element): Promise<Element | null> {\n    // tslint:disable-next-line:prefer-const\n    let { tree: includedTree, resolved } =\n      await loadFromElement(currentBase, seenURLs, el, this.parser);\n    includedTree = await this.walk(resolved,\n                                   [resolved.toString(), ...seenURLs],\n                                   includedTree);\n    const ns = el.getAttribute(\"ns\");\n    const treeNs = includedTree.getAttribute(\"ns\");\n    if (ns !== undefined && treeNs === undefined) {\n      includedTree.setAttribute(\"ns\", ns);\n    }\n\n    // See the comment in ``include`` below for the rational as to why we are\n    // setting the value here.\n    if (includedTree.getAttribute(\"datatypeLibrary\") === undefined) {\n      includedTree.setAttribute(\"datatypeLibrary\", \"\");\n    }\n\n    // If parent is null then we are at the root and we cannot remove the\n    // element.\n    if (el.parent !== undefined) {\n      // By this point, the tree's default namespace is the Relax NG one. So we\n      // can remove it to avoid redeclaring it. We don't want to do this though\n      // if we're forming the root of the new tree.\n      includedTree.removeAttribute(\"xmlns\");\n\n      el.parent!.replaceChildWith(el, includedTree);\n    }\n\n    return includedTree;\n  }\n\n  async include(currentBase: URL, seenURLs: string[],\n                el: Element): Promise<Element | null> {\n    const { tree: includedTree, resolved } =\n      await loadFromElement(currentBase, seenURLs, el, this.parser);\n    await this.walk(resolved, [resolved.toString(), ...seenURLs],\n                    includedTree);\n\n    // By this point, the tree's default namespace is the Relax NG one. So we\n    // can remove it to avoid redeclaring it.\n    includedTree.removeAttribute(\"xmlns\");\n    if (includedTree.local !== \"grammar\") {\n      throw new SchemaValidationError(\"include does not point to a document \" +\n                                      \"that has a grammar element as root\");\n    }\n\n    const { start: includeStarts, define: includeDefs } =\n      findMultiDescendantsByLocalName(el, [\"start\", \"define\"]);\n    const { start: grammarStarts, define: grammarDefs } =\n      findMultiDescendantsByLocalName(includedTree, [\"start\", \"define\"]);\n    if (includeStarts.length !== 0) {\n      if (grammarStarts.length === 0) {\n        throw new SchemaValidationError(\n          \"include contains start element but grammar does not\");\n      }\n      for (const start of grammarStarts) {\n        start.parent!.removeChild(start);\n      }\n    }\n\n    const includeDefsMap = indexBy(includeDefs, getName);\n    const grammarDefsMap = groupBy(grammarDefs, getName);\n\n    for (const key of includeDefsMap.keys()) {\n      const defs = grammarDefsMap.get(key);\n\n      if (defs === undefined) {\n        throw new SchemaValidationError(\n          `include has define with name ${name} which is not present in \\\ngrammar`);\n      }\n\n      for (const def of defs) {\n        def.parent!.removeChild(def);\n      }\n    }\n    el.local = \"div\";\n    el.removeAttribute(\"href\");\n    includedTree.local = \"div\";\n\n    //\n    // In the RNG specification, the propagation of datatypeLibrary elements is\n    // an earlier processing step (4.3) than the resolution of external\n    // references (4.5). This means that upon reading an external resource, an\n    // algorithm that follows the spec to the letter would have to apply to the\n    // resource the steps 4.1 to 4.4 before resolving any external references in\n    // the newly loaded resource.\n    //\n    // Here we follow the order set in the XSL pipeline: we first resolve all\n    // external references and then later we will propagate datatypeLibrary.\n    //\n    // This deivation from the spec requires that if datatypeLibrary is not set\n    // on a imported element we MUST set it to the empty string. Otherwise, when\n    // we do propagate datatypeLibrary, it would \"cross\" resource boundaries, so\n    // to speak. This would be incorrect.\n    //\n    if (includedTree.getAttribute(\"datatypeLibrary\") === undefined) {\n      includedTree.setAttribute(\"datatypeLibrary\", \"\");\n    }\n    // Insert the grammar element (now named \"div\") into the include element\n    // (also now named \"div\").\n    el.prependChild(includedTree);\n\n    return null;\n  }\n}\n\n/**\n * Modify the tree:\n *\n * - All references to external resources (``externalRef`` and ``include``) are\n *   replaced by the contents of the references. It essentially \"flattens\" a\n *   schema made of group of documents to a single document.\n *\n * - Remove text nodes that contain only white spaces.  Text nodes in the\n *   elements ``param`` and ``value`` are excluded.\n *\n * - Trim the text node in the elements named ``name``.\n *\n * - Also trim the values of the attributes ``name``, ``type`` and ``combine``.\n *\n * Note that step1 also subsumes what was step2 and step3 in the XSLT-based\n * transforms.\n *\n * @param documentBase The base URI of the tree being processed.\n *\n * @param tree The XML tree to process.\n *\n * @param parser A function through which we load and parse XML files.\n *\n * @returns A promise that resolves to the new tree root when processing is\n * done.\n */\nexport async function step1(documentBase: URL,\n                            tree: Element,\n                            parser: Parser): Promise<Element> {\n  return new Step1(parser).walk(documentBase, [documentBase.toString()], tree);\n}\n"]}