{"version":3,"file":"attribute.js","sourceRoot":"","sources":["../../../../lib/salve/patterns/attribute.ts"],"names":[],"mappings":";;;AAOA,sCAAoE;AACpE,sCAAoE;AAGpE,gCAA6B;AAC7B,iCACiC;AACjC,iCAA8B;AAE9B,iCAA8B;AAQ9B;;GAEG;AACH,MAAa,SAAU,SAAQ,cAAO;IAGpC;;;;;;;OAOG;IAEH,YAAY,OAAe,EAAW,IAAkB,EACnC,GAAY;QAC/B,KAAK,CAAC,OAAO,CAAC,CAAC;QAFqB,SAAI,GAAJ,IAAI,CAAc;QACnC,QAAG,GAAH,GAAG,CAAS;QAE/B,IAAI,GAAG,YAAY,WAAI,EAAE;YACvB,IAAI,CAAC,IAAI,eAAY,CAAC;SACvB;aACI,IAAI,GAAG,YAAY,WAAI,EAAE;YAC5B,IAAI,CAAC,IAAI,eAAY,CAAC;SACvB;aACI;YACH,IAAI,CAAC,IAAI,kBAAe,CAAC;SAC1B;IACH,CAAC;IAED,QAAQ,CAAC,WAAgC,EAAE,UAAuB;QAChE,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACjD,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC;IACd,CAAC;IAED,eAAe;QACb,OAAO,KAAK,CAAC;IACf,CAAC;IAED,SAAS;QACP,QAAQ,IAAI,CAAC,IAAI,EAAE;YACjB;gBACE,OAAO,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvE;gBACE,MAAM,GAAG,GAAG,IAAI,CAAC,GAAW,CAAC;gBAC7B,OAAO,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,EAC7B,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EACpC,KAAK,CAAC,CAAC;YACxC;gBACE,iDAAiD;gBACjD,OAAO,IAAI,eAAe,CAAC,IAAI,EACJ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,EACpB,KAAK,EAAE,cAAc,CACrB,KAAK,EACL,KAAK,CAAC,CAAC;SACrC;IACH,CAAC;CACF;AA1DD,8BA0DC;AAED;;GAEG;AACH,MAAM,eAAe;IAEnB;;OAEG;IACH,YAA+B,EAAa,EACf,IAAkB,EAClB,SAAyB,EAClC,QAAiB,EAClB,eAAwB,EACxB,MAAe;QALH,OAAE,GAAF,EAAE,CAAW;QACf,SAAI,GAAJ,IAAI,CAAc;QAClB,cAAS,GAAT,SAAS,CAAgB;QAClC,aAAQ,GAAR,QAAQ,CAAS;QAClB,oBAAe,GAAf,eAAe,CAAS;QACxB,WAAM,GAAN,MAAM,CAAS;IAClC,CAAC;IAED,KAAK;QACH,OAAO,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,EACtB,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,MAAM,CAAS,CAAC;IAClD,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,GAAG,EAAE,CAAC;IACnB,CAAC;IAED,kBAAkB;QAChB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,GAAG,EAAE,CAAC;SAClB;QAED,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,OAAO,IAAI,GAAG,CAAC,CAAC,IAAI,2BAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACrD;QAED,gDAAgD;QAChD,OAAO,SAAG,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,EAAE;YACzC,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,EAAE;gBACtB,MAAM,IAAI,KAAK,CAAC,0BAA0B,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;aACtD;YACD,OAAO,IAAI,4BAAmB,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,aAAa,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;IACL,CAAC;IAED,SAAS,CAAC,IAAY,EAAE,MAAgB,EAC9B,YAA0B;QAClC,iEAAiE;QACjE,uBAAuB;QACvB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,KAAa,CAAC;QAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,IAAI,KAAK,gBAAgB,EAAE;gBAC7B,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;aAC3C;YAED,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACnB;aACI,IAAI,CAAC,IAAI,KAAK,uBAAuB,IAAI,IAAI,KAAK,eAAe,CAAC;YAC9D,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAC9C,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAErB,IAAI,IAAI,KAAK,eAAe,EAAE;gBAC5B,OAAO,IAAI,8BAAuB,CAAC,IAAI,CAAC,CAAC;aAC1C;YAED,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACnB;aACI;YACH,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,IAAI,KAAK,KAAK,EAAE;YACZ,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,YAAY,CAAC,CAAC,OAAO,EAAE;YACpE,OAAO,IAAI,8BAAuB,CAChC,KAAK,EACL,CAAC,IAAI,4BAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACpE;QAED,OAAO,8BAAuB,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC;IACrE,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,KAAK,CAAC;SACd;QAED,yEAAyE;QACzE,qEAAqE;QACrE,iEAAiE;QACjE,kDAAkD;QAClD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACf,IAAI,4BAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/D,IAAI,2BAAkB,CAAC,mBAAmB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,GAAG;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED;;;;GAIG;AACH,MAAM,mBAAmB;IAEvB;;OAEG;IACH,YAA+B,EAAa,EACf,IAAkB,EAC3B,QAAiB,EAClB,eAAwB,EACxB,MAAe;QAJH,OAAE,GAAF,EAAE,CAAW;QACf,SAAI,GAAJ,IAAI,CAAc;QAC3B,aAAQ,GAAR,QAAQ,CAAS;QAClB,oBAAe,GAAf,eAAe,CAAS;QACxB,WAAM,GAAN,MAAM,CAAS;IAClC,CAAC;IAED,KAAK;QACH,OAAO,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,MAAM,CAAS,CAAC;IACtD,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,GAAG,EAAE,CAAC;IACnB,CAAC;IAED,kBAAkB;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;YAClB,IAAI,GAAG,EAAE,CAAC,CAAC;YACX,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACf,IAAI,4BAAmB,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACnC,IAAI,2BAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC;IAED,SAAS,CAAC,IAAY,EAAE,MAAgB,EAC9B,YAA0B;QAClC,iEAAiE;QACjE,uBAAuB;QACvB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,IAAI,KAAK,gBAAgB,EAAE;gBAC7B,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;aAC3C;SACF;aACI,IAAI,CAAC,IAAI,KAAK,uBAAuB,IAAI,IAAI,KAAK,eAAe,CAAC;YAC9D,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAC9C,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAErB,IAAI,IAAI,KAAK,eAAe,EAAE;gBAC5B,OAAO,IAAI,8BAAuB,CAAC,IAAI,CAAC,CAAC;aAC1C;SACF;aACI;YACH,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,OAAO,IAAI,8BAAuB,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,KAAK,CAAC;SACd;QAED,yEAAyE;QACzE,qEAAqE;QACrE,iEAAiE;QACjE,kDAAkD;QAClD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACf,IAAI,4BAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/D,IAAI,2BAAkB,CAAC,mBAAmB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,GAAG;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED;;;GAGG;AACH,MAAM,mBAAmB;IAEvB;;OAEG;IACH,YAA+B,EAAa,EACf,IAAkB,EAClB,QAAkB,EAClB,MAAoB,EACpB,MAA2B,EACpC,QAAiB,EAClB,eAAwB,EACxB,MAAe;QAPH,OAAE,GAAF,EAAE,CAAW;QACf,SAAI,GAAJ,IAAI,CAAc;QAClB,aAAQ,GAAR,QAAQ,CAAU;QAClB,WAAM,GAAN,MAAM,CAAc;QACpB,WAAM,GAAN,MAAM,CAAqB;QACpC,aAAQ,GAAR,QAAQ,CAAS;QAClB,oBAAe,GAAf,eAAe,CAAS;QACxB,WAAM,GAAN,MAAM,CAAS;IAClC,CAAC;IAED,KAAK;QACH,OAAO,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,MAAM,CAAS,CAAC;IACtD,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,GAAG,EAAE,CAAC;IACnB,CAAC;IAED,kBAAkB;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;YAClB,IAAI,GAAG,EAAE,CAAC,CAAC;YACX,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACf,IAAI,4BAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;oBAC/C,IAAI,2BAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC;IAED,SAAS,CAAC,IAAY,EAAE,MAAgB,EAC9B,YAA0B;QAClC,iEAAiE;QACjE,uBAAuB;QACvB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,KAAa,CAAC;QAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,IAAI,KAAK,gBAAgB,EAAE;gBAC7B,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;aAC3C;YAED,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACnB;aACI,IAAI,CAAC,IAAI,KAAK,uBAAuB,IAAI,IAAI,KAAK,eAAe,CAAC;YAC9D,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAC9C,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAErB,IAAI,IAAI,KAAK,eAAe,EAAE;gBAC5B,OAAO,IAAI,8BAAuB,CAAC,IAAI,CAAC,CAAC;aAC1C;YAED,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACnB;aACI;YACH,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAClB,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAC5B,EAAE,QAAQ,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE;YACnE,OAAO,IAAI,8BAAuB,CAChC,KAAK,EACL,CAAC,IAAI,4BAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACpE;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;YAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;YACvC,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;YAE/D,qEAAqE;YACrE,gBAAgB;YAChB,IAAI,SAAS,CAAC,OAAO,EAAE;gBACrB,OAAO,IAAI,8BAAuB,CAAC,KAAK,CAAC,CAAC;aAC3C;YAED,qEAAqE;YACrE,uEAAuE;YACvE,uEAAuE;YACvE,oBAAoB;SACrB;QAED,OAAO,IAAI,8BAAuB,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,KAAK,CAAC;SACd;QAED,yEAAyE;QACzE,qEAAqE;QACrE,iEAAiE;QACjE,kDAAkD;QAClD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAE5B,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACf,IAAI,4BAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/D,IAAI,2BAAkB,CAAC,mBAAmB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,GAAG;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED,qEAAqE;AACrE,oCAAoC","sourcesContent":["/**\n * Pattern and walker for RNG's ``attribute`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { Datatype, ParsedParams } from \"../datatypes\";\nimport { AttributeNameError, AttributeValueError } from \"../errors\";\nimport { AttributeNameEvent, AttributeValueEvent } from \"../events\";\nimport { ConcreteName } from \"../name_patterns\";\nimport { NameResolver } from \"../name_resolver\";\nimport { map } from \"../set\";\nimport { EndResult, EventSet, InternalFireEventResult, InternalWalker,\n         Pattern } from \"./base\";\nimport { Data } from \"./data\";\nimport { Define } from \"./define\";\nimport { Text } from \"./text\";\n\nconst enum Kind {\n  DEFAULT,\n  TEXT,\n  DATA,\n}\n\n/**\n * A pattern for attributes.\n */\nexport class Attribute extends Pattern {\n  private readonly kind: Kind;\n\n  /**\n   * @param xmlPath This is a string which uniquely identifies the\n   * element from the simplified RNG tree. Used in debugging.\n   *\n   * @param name The qualified name of the attribute.\n   *\n   * @param pat The pattern contained by this one.\n   */\n\n  constructor(xmlPath: string, readonly name: ConcreteName,\n              readonly pat: Pattern) {\n    super(xmlPath);\n    if (pat instanceof Text) {\n      this.kind = Kind.TEXT;\n    }\n    else if (pat instanceof Data) {\n      this.kind = Kind.DATA;\n    }\n    else {\n      this.kind = Kind.DEFAULT;\n    }\n  }\n\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n    this.pat._prepare(definitions, namespaces);\n    this.name._recordNamespaces(namespaces, false);\n  }\n\n  hasAttrs(): boolean {\n    return true;\n  }\n\n  hasEmptyPattern(): boolean {\n    return false;\n  }\n\n  newWalker(): InternalWalker {\n    switch (this.kind) {\n      case Kind.TEXT:\n        return new AttributeTextWalker(this, this.name, false, false, false);\n      case Kind.DATA:\n        const pat = this.pat as Data;\n        return new AttributeDataWalker(this, this.name, pat.datatype,\n                                       pat.params, pat.except, false, false,\n                                       false);\n      default:\n        // tslint:disable-next-line:no-use-before-declare\n        return new AttributeWalker(this,\n                                   this.name,\n                                   this.pat.newWalker(),\n                                   false, /* seenName */\n                                   false,\n                                   false);\n    }\n  }\n}\n\n/**\n * Walker for [[Attribute]].\n */\nclass AttributeWalker implements InternalWalker {\n\n  /**\n   * @param el The pattern for which this walker was created.\n   */\n  constructor(protected readonly el: Attribute,\n              private readonly name: ConcreteName,\n              private readonly subwalker: InternalWalker,\n              private seenName: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {\n  }\n\n  clone(): this {\n    return new AttributeWalker(this.el,\n                               this.name,\n                               this.subwalker.clone(),\n                               this.seenName,\n                               this.canEndAttribute,\n                               this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    return new Set();\n  }\n\n  possibleAttributes(): EventSet {\n    if (this.canEnd) {\n      return new Set();\n    }\n\n    if (!this.seenName) {\n      return new Set([new AttributeNameEvent(this.name)]);\n    }\n\n    // Convert text events to attributeValue events.\n    return map(this.subwalker.possible(), ev => {\n      if (ev.name !== \"text\") {\n        throw new Error(`unexpected event type: ${ev.name}`);\n      }\n      return new AttributeValueEvent(ev.value, ev.documentation);\n    });\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    // If canEnd is true, we've done everything we could. So we don't\n    // want to match again.\n    if (this.canEnd) {\n      return new InternalFireEventResult(false);\n    }\n\n    let value: string;\n    if (this.seenName) {\n      if (name !== \"attributeValue\") {\n        return new InternalFireEventResult(false);\n      }\n\n      value = params[0];\n    }\n    else if ((name === \"attributeNameAndValue\" || name === \"attributeName\") &&\n             this.name.match(params[0], params[1])) {\n      this.seenName = true;\n\n      if (name === \"attributeName\") {\n        return new InternalFireEventResult(true);\n      }\n\n      value = params[2];\n    }\n    else {\n      return new InternalFireEventResult(false);\n    }\n\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    if (value !== \"\" &&\n        !this.subwalker.fireEvent(\"text\", [value], nameResolver).matched) {\n      return new InternalFireEventResult(\n        false,\n        [new AttributeValueError(\"invalid attribute value\", this.name)]);\n    }\n\n    return InternalFireEventResult.fromEndResult(this.subwalker.end());\n  }\n\n  endAttributes(): EndResult {\n    if (this.canEnd) {\n      return false;\n    }\n\n    // We set the canEnd flags true even though we did not end properly. This\n    // prevents producing errors about the same attribute multiple times,\n    // because end is called by element walkers when leaveStartTag is\n    // encountered, and again when the element closes.\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    return [this.seenName ?\n            new AttributeValueError(\"attribute value missing\", this.name) :\n            new AttributeNameError(\"attribute missing\", this.name)];\n  }\n\n  end(): EndResult {\n    return false;\n  }\n}\n\n/**\n * This is a specialized walker for attributes that contain <text/> (which is\n * the default when an attribute does not have a more specific content\n * specified).\n */\nclass AttributeTextWalker implements InternalWalker {\n\n  /**\n   * @param el The pattern for which this walker was created.\n   */\n  constructor(protected readonly el: Attribute,\n              private readonly name: ConcreteName,\n              private seenName: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {\n  }\n\n  clone(): this {\n    return new AttributeTextWalker(this.el,\n                                   this.name,\n                                   this.seenName,\n                                   this.canEndAttribute,\n                                   this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    return new Set();\n  }\n\n  possibleAttributes(): EventSet {\n    return this.canEnd ?\n      new Set() :\n      new Set([this.seenName ?\n               new AttributeValueEvent(/^[^]*$/) :\n               new AttributeNameEvent(this.name)]);\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    // If canEnd is true, we've done everything we could. So we don't\n    // want to match again.\n    if (this.canEnd) {\n      return new InternalFireEventResult(false);\n    }\n\n    if (this.seenName) {\n      if (name !== \"attributeValue\") {\n        return new InternalFireEventResult(false);\n      }\n    }\n    else if ((name === \"attributeNameAndValue\" || name === \"attributeName\") &&\n             this.name.match(params[0], params[1])) {\n      this.seenName = true;\n\n      if (name === \"attributeName\") {\n        return new InternalFireEventResult(true);\n      }\n    }\n    else {\n      return new InternalFireEventResult(false);\n    }\n\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    return new InternalFireEventResult(true);\n  }\n\n  endAttributes(): EndResult {\n    if (this.canEnd) {\n      return false;\n    }\n\n    // We set the canEnd flags true even though we did not end properly. This\n    // prevents producing errors about the same attribute multiple times,\n    // because end is called by element walkers when leaveStartTag is\n    // encountered, and again when the element closes.\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    return [this.seenName ?\n            new AttributeValueError(\"attribute value missing\", this.name) :\n            new AttributeNameError(\"attribute missing\", this.name)];\n  }\n\n  end(): EndResult {\n    return false;\n  }\n}\n\n/**\n * This is a specialized walker for attributes that contain <data> (which is\n * rather common).\n */\nclass AttributeDataWalker implements InternalWalker {\n\n  /**\n   * @param el The pattern for which this walker was created.\n   */\n  constructor(protected readonly el: Attribute,\n              private readonly name: ConcreteName,\n              private readonly datatype: Datatype,\n              private readonly params: ParsedParams,\n              private readonly except: Pattern | undefined,\n              private seenName: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {\n  }\n\n  clone(): this {\n    return new AttributeDataWalker(this.el,\n                                   this.name,\n                                   this.datatype,\n                                   this.params,\n                                   this.except,\n                                   this.seenName,\n                                   this.canEndAttribute,\n                                   this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    return new Set();\n  }\n\n  possibleAttributes(): EventSet {\n    return this.canEnd ?\n      new Set() :\n      new Set([this.seenName ?\n               new AttributeValueEvent(this.datatype.regexp) :\n               new AttributeNameEvent(this.name)]);\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    // If canEnd is true, we've done everything we could. So we don't\n    // want to match again.\n    if (this.canEnd) {\n      return new InternalFireEventResult(false);\n    }\n\n    let value: string;\n    if (this.seenName) {\n      if (name !== \"attributeValue\") {\n        return new InternalFireEventResult(false);\n      }\n\n      value = params[0];\n    }\n    else if ((name === \"attributeNameAndValue\" || name === \"attributeName\") &&\n             this.name.match(params[0], params[1])) {\n      this.seenName = true;\n\n      if (name === \"attributeName\") {\n        return new InternalFireEventResult(true);\n      }\n\n      value = params[2];\n    }\n    else {\n      return new InternalFireEventResult(false);\n    }\n\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    if (this.datatype.disallows(value, this.params,\n                                this.datatype.needsContext ?\n                                { resolver: nameResolver } : undefined)) {\n      return new InternalFireEventResult(\n        false,\n        [new AttributeValueError(\"invalid attribute value\", this.name)]);\n    }\n\n    if (this.except !== undefined) {\n      const walker = this.except.newWalker();\n      const exceptRet = walker.fireEvent(name, params, nameResolver);\n\n      // False, so the except does match the text, and so this pattern does\n      // not match it.\n      if (exceptRet.matched) {\n        return new InternalFireEventResult(false);\n      }\n\n      // Otherwise, it is undefined, in which case it means the except does\n      // not match the text, and we are fine. Or it would be possible for the\n      // walker to have returned an error but there is nothing we can do with\n      // such errors here.\n    }\n\n    return new InternalFireEventResult(true);\n  }\n\n  endAttributes(): EndResult {\n    if (this.canEnd) {\n      return false;\n    }\n\n    // We set the canEnd flags true even though we did not end properly. This\n    // prevents producing errors about the same attribute multiple times,\n    // because end is called by element walkers when leaveStartTag is\n    // encountered, and again when the element closes.\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    return [this.seenName ?\n            new AttributeValueError(\"attribute value missing\", this.name) :\n            new AttributeNameError(\"attribute missing\", this.name)];\n  }\n\n  end(): EndResult {\n    return false;\n  }\n}\n\n//  LocalWords:  RNG's MPL RNG attributeName attributeValue ev params\n//  LocalWords:  neutralizeAttribute\n"]}