{"version":3,"file":"data.js","sourceRoot":"","sources":["../../../../lib/salve/patterns/data.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Pattern and walker for RNG's ``data`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { Datatype, ParsedParams, RawParameter, registry } from \"../datatypes\";\nimport { ValidationError } from \"../errors\";\nimport { TextEvent } from \"../events\";\nimport { NameResolver } from \"../name_resolver\";\nimport { EndResult, EventSet, InternalFireEventResult, InternalWalker,\n         Pattern } from \"./base\";\n/**\n * Data pattern.\n */\nexport class Data extends Pattern {\n  readonly datatype: Datatype;\n  readonly rngParams?: RawParameter[];\n  private _params?: ParsedParams;\n  private _allowsEmptyContent?: boolean;\n\n  /**\n   *\n   * @param xmlPath This is a string which uniquely identifies the\n   * element from the simplified RNG tree. Used in debugging.\n   *\n   * @param type The type of value.\n   *\n   * @param datatypeLibrary The URI of the datatype library to use.\n   *\n   * @param params The parameters from the RNG file.\n   *\n   * @param except The exception pattern.\n   */\n  // tslint:disable-next-line: no-reserved-keywords\n  constructor(xmlPath: string, readonly type: string = \"token\",\n              readonly datatypeLibrary: string = \"\", params?: RawParameter[],\n              readonly except?: Pattern) {\n    super(xmlPath);\n    const datatype = this.datatype =\n      registry.get(this.datatypeLibrary).types[this.type];\n    if (datatype === undefined) {\n      throw new Error(`unknown type: ${type}`);\n    }\n    this.rngParams = params;\n  }\n\n  get params(): ParsedParams {\n    let ret = this._params;\n    if (ret !== undefined) {\n      return ret;\n    }\n\n    ret = this._params = this.datatype.parseParams(this.xmlPath,\n                                                   this.rngParams);\n\n    return ret;\n  }\n\n  get allowsEmptyContent(): boolean {\n    let ret = this._allowsEmptyContent;\n\n    if (ret !== undefined) {\n      return ret;\n    }\n\n    const { except, params, datatype } = this;\n    ret = this._allowsEmptyContent =\n      !(except !== undefined && except.hasEmptyPattern()) &&\n      !datatype.disallows(\"\", params);\n\n    return ret;\n  }\n\n  newWalker(): InternalWalker {\n    const { allowsEmptyContent } = this;\n\n    // tslint:disable-next-line:no-use-before-declare\n    return new DataWalker(this,\n                          this.datatype,\n                          this.params,\n                          this.except,\n                          false,\n                          allowsEmptyContent,\n                          allowsEmptyContent);\n  }\n}\n\n/**\n * Walker for [[Data]].\n */\nclass DataWalker implements InternalWalker {\n  constructor(protected readonly el: Data,\n              private readonly datatype: Datatype,\n              private readonly params: ParsedParams,\n              private readonly except: Pattern | undefined,\n              private matched: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {}\n\n  clone(): this {\n    return new DataWalker(this.el,\n                          this.el.datatype,\n                          this.el.params,\n                          this.el.except,\n                          this.matched,\n                          this.canEndAttribute,\n                          this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    // We completely ignore the possible exception when producing the\n    // possibilities. There is no clean way to specify such an exception.\n    return new Set(this.matched ? undefined :\n                   [new TextEvent(this.datatype.regexp)]);\n  }\n\n  possibleAttributes(): EventSet {\n    return new Set();\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    if (this.matched || name !== \"text\" ||\n        this.datatype.disallows(params[0], this.params,\n                                { resolver: nameResolver })) {\n      return new InternalFireEventResult(false);\n    }\n\n    if (this.except !== undefined) {\n      const walker = this.except.newWalker();\n      const exceptRet = walker.fireEvent(name, params, nameResolver);\n\n      // False, so the except does match the text, and so this pattern does\n      // not match it.\n      if (exceptRet.matched) {\n        return new InternalFireEventResult(false);\n      }\n\n      // Otherwise, it is undefined, in which case it means the except does\n      // not match the text, and we are fine. Or it would be possible for the\n      // walker to have returned an error but there is nothing we can do with\n      // such errors here.\n    }\n\n    // If we matched, we are done. salve does not allow text that appears in\n    // an XML element to be passed as two \"text\" events. So there is nothing\n    // to come that could falsify the match. (If a client *does* pass\n    // multiple text events one after the other, it is using salve\n    // incorrectly.)\n    this.matched = true;\n    this.canEnd = true;\n    this.canEndAttribute = true;\n\n    return new InternalFireEventResult(true);\n  }\n\n  end(): EndResult {\n    return this.canEnd ? false : [new ValidationError(\"value required\")];\n  }\n\n  endAttributes(): EndResult {\n    return false;\n  }\n}\n\n//  LocalWords:  RNG's MPL RNG nd possibleCached\n"]}