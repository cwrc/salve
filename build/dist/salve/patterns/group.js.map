{"version":3,"file":"group.js","sourceRoot":"","sources":["../../../../lib/salve/patterns/group.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Pattern and walker for RNG's ``group`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { AttributeNameError, AttributeValueError } from \"../errors\";\nimport { NameResolver } from \"../name_resolver\";\nimport { union } from \"../set\";\nimport { EndResult, EventSet, InternalFireEventResult, InternalWalker,\n         isAttributeEvent, TwoSubpatterns } from \"./base\";\n\n/**\n * A pattern for ``<group>``.\n */\nexport class Group extends TwoSubpatterns {\n  protected _computeHasEmptyPattern(): boolean {\n    return this.patA.hasEmptyPattern() && this.patB.hasEmptyPattern();\n  }\n\n  newWalker(): InternalWalker {\n    const hasAttrs = this.hasAttrs();\n    const walkerA = this.patA.newWalker();\n    const walkerB = this.patB.newWalker();\n\n    // tslint:disable-next-line:no-use-before-declare\n    return new GroupWalker(this,\n                           walkerA,\n                           walkerB,\n                           hasAttrs,\n                           false,\n                           false,\n                           !hasAttrs ||\n                           (walkerA.canEndAttribute && walkerB.canEndAttribute),\n                           walkerA.canEnd && walkerB.canEnd);\n  }\n}\n\n/**\n * Walker for [[Group]].\n */\nclass GroupWalker implements InternalWalker {\n  constructor(protected readonly el: Group,\n              private readonly walkerA: InternalWalker,\n              private readonly walkerB: InternalWalker,\n              private readonly hasAttrs: boolean,\n              private ended: boolean,\n              private endedA: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {}\n\n  clone(): this {\n    return new GroupWalker(this.el,\n                           this.walkerA.clone(),\n                           this.walkerB.clone(),\n                           this.hasAttrs,\n                           this.ended,\n                           this.endedA,\n                           this.canEndAttribute,\n                           this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    if (this.ended) {\n      return new Set();\n    }\n\n    const ret = this.walkerA.possible();\n\n    if (this.walkerA.canEnd) {\n      union(ret, this.walkerB.possible());\n    }\n\n    return ret;\n  }\n\n  possibleAttributes(): EventSet {\n    if (this.ended) {\n      return new Set();\n    }\n\n    const ret = this.walkerA.possibleAttributes();\n    union(ret, this.walkerB.possibleAttributes());\n\n    return ret;\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    const evIsAttributeEvent = isAttributeEvent(name);\n\n    if (evIsAttributeEvent && !this.hasAttrs) {\n      return new InternalFireEventResult(false);\n    }\n\n    //\n    // fireEvent is not called after ended becomes true\n    //\n    // if (this.ended) {\n    //   return new InternalFireEventResult(false);\n    // }\n\n    const { walkerA, walkerB } = this;\n    if (!this.endedA) {\n      const retA = walkerA.fireEvent(name, params, nameResolver);\n      if (retA.matched || retA.errors !== undefined) {\n        this.canEndAttribute = walkerA.canEndAttribute &&\n          walkerB.canEndAttribute;\n        this.canEnd = walkerA.canEnd && walkerB.canEnd;\n\n        return retA;\n      }\n\n      // We must return right away if walkerA cannot yet end. Only attribute\n      // events are allowed to move forward.\n      if (!evIsAttributeEvent && !walkerA.canEnd) {\n        return retA;\n      }\n    }\n\n    const retB = walkerB.fireEvent(name, params, nameResolver);\n    this.canEndAttribute = walkerA.canEndAttribute && walkerB.canEndAttribute;\n    this.canEnd = walkerA.canEnd && walkerB.canEnd;\n\n    // Non-attribute event: if walker b matched the event then we must end\n    // walkerA, if we've not already done so.\n    if (!evIsAttributeEvent && retB.matched) {\n      this.endedA = true;\n\n      // Having an end that errors here is not possible.\n      if (walkerA.end() !== false) {\n        throw new Error(\"walkerA can end but does not end cleanly!\");\n      }\n    }\n\n    return retB;\n  }\n\n  end(): EndResult {\n    if (this.ended) {\n      return false;\n    }\n\n    if (this.canEnd) {\n      this.ended = true;\n\n      return false;\n    }\n\n    const retA = this.walkerA.end();\n    // If we get here and the only errors we get are attribute errors, we must\n    // move on to check the second walker too.\n    if (retA) {\n      for (const err of retA) {\n        if (!(err instanceof AttributeValueError ||\n              err instanceof AttributeNameError)) {\n          // We ran into a non-attribute error. We can stop here.\n          return retA;\n        }\n      }\n    }\n\n    const retB = this.walkerB.end();\n    if (retB) {\n      return retA ? retA.concat(retB) : retB;\n    }\n\n    return retA;\n  }\n\n  endAttributes(): EndResult {\n    if (this.canEndAttribute) {\n      return false;\n    }\n\n    const endA = this.walkerA.endAttributes();\n    const endB = this.walkerB.endAttributes();\n\n    if (endB) {\n      return endA ? endA.concat(endB) : endB;\n    }\n\n    return endA;\n  }\n}\n\n//  LocalWords:  RNG's MPL instantiateWalkers walkerA retB canEnd endedA\n"]}