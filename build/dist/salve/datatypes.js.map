{"version":3,"file":"datatypes.js","sourceRoot":"","sources":["../../../lib/salve/datatypes.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;AAEH,iDAA8C;AAE9C,qDAAkD;AAElD;;GAEG;AACH,MAAa,QAAQ;IAArB;QACmB,cAAS,GACtB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IA+C1B,CAAC;IA7CC;;;;;;OAMG;IACH,GAAG,CAAC,OAAoB;QACtB,MAAM,GAAG,GAAW,OAAO,CAAC,GAAG,CAAC;QAChC,IAAI,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC,CAAC;SACtC;QACD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;IAChC,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,CAAC,GAAW;QACd,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IAED;;;;;;;;OAQG;IACH,iDAAiD;IACjD,GAAG,CAAC,GAAW;QACb,MAAM,GAAG,GAA4B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACpD,IAAI,GAAG,KAAK,SAAS,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,+BAA+B,GAAG,EAAE,CAAC,CAAC;SACvD;QAED,OAAO,GAAG,CAAC;IACb,CAAC;CACF;AAjDD,4BAiDC;AAEY,QAAA,QAAQ,GAAa,IAAI,QAAQ,EAAE,CAAC;AACjD,gBAAQ,CAAC,GAAG,CAAC,iBAAO,CAAC,CAAC;AACtB,gBAAQ,CAAC,GAAG,CAAC,qBAAS,CAAC,CAAC;AAExB,6CAC0B;AADjB,+GAAA,qBAAqB,OAAA;AAAE,8GAAA,oBAAoB,OAAA;AAAE,oGAAA,UAAU,OAAA;AAKhE,sCAAsC","sourcesContent":["/**\n * Classes that model datatypes used in RNG schemas.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n *\n */\n\nimport { builtin } from \"./datatypes/builtin\";\nimport { TypeLibrary } from \"./datatypes/library\";\nimport { xmlschema } from \"./datatypes/xmlschema\";\n\n/**\n * The registry of types.\n */\nexport class Registry {\n  private readonly libraries: { [name: string]: TypeLibrary}\n    = Object.create(null);\n\n  /**\n   * Adds a library to the registry.\n   *\n   * @param library The library to add to the registry.\n   *\n   * @throws {Error} If the URI is already registered.\n   */\n  add(library: TypeLibrary): void {\n    const uri: string = library.uri;\n    if (uri in this.libraries) {\n      throw new Error(`URI clash: ${uri}`);\n    }\n    this.libraries[uri] = library;\n  }\n\n  /**\n   * Searches for a URI in the library.\n   *\n   * @param uri The URI to search for.\n   *\n   * @returns The library that corresponds to the URI or ``undefined`` if no\n   * such library exists.\n   */\n  find(uri: string): TypeLibrary | undefined {\n    return this.libraries[uri];\n  }\n\n  /**\n   * Gets the library corresponding to a URI.\n   *\n   * @param uri The URI.\n   *\n   * @returns The library that corresponds to the URI.\n   *\n   * @throws {Error} If the library does not exist.\n   */\n  // tslint:disable-next-line: no-reserved-keywords\n  get(uri: string): TypeLibrary {\n    const ret: TypeLibrary | undefined = this.find(uri);\n    if (ret === undefined) {\n      throw new Error(`can't get library with URI: ${uri}`);\n    }\n\n    return ret;\n  }\n}\n\nexport const registry: Registry = new Registry();\nregistry.add(builtin);\nregistry.add(xmlschema);\n\nexport { ParameterParsingError, ValueValidationError, ValueError }\nfrom \"./datatypes/errors\";\nexport { Datatype, ParsedParams, RawParameter,\n         TypeLibrary } from \"./datatypes/library\";\n\n//  LocalWords:  datatypes RNG MPL uri\n"]}