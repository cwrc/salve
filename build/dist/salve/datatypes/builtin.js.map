{"version":3,"file":"builtin.js","sourceRoot":"","sources":["../../../../lib/salve/datatypes/builtin.ts"],"names":[],"mappings":";;;AAAA;;;;;GAKG;AACH,qCAAyE;AAIzE;;;;;;;;;GASG;AACH,SAAS,cAAc,CAAC,KAAa;IACnC,wCAAwC;IACxC,OAAO,KAAK,CAAC,IAAI,EAAE,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC3C,CAAC;AAED,EAAE;AACF,0EAA0E;AAC1E,gBAAgB;AAChB,EAAE;AACF,0DAA0D;AAC1D,EAAE;AACF,MAAe,IAAI;IAKjB,WAAW,CAAC,QAAgB,EAAE,MAAuB;QACnD,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YAC7C,MAAM,IAAI,8BAAqB,CAC7B,QAAQ,EACR,CAAC,IAAI,mBAAU,CAAC,sCAAsC,CAAC,CAAC,CAAC,CAAC;SAC7D;QAED,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;CAOF;AAED,MAAM,OAAQ,SAAQ,IAAI;IAA1B;;QAEW,WAAM,GAAW,QAAQ,CAAC;QAC1B,iBAAY,GAAY,KAAK,CAAC;IAezC,CAAC;IAbC,UAAU,CAAC,QAAgB,EAAE,KAAa;QACxC,4EAA4E;QAC5E,mCAAmC;QACnC,OAAO,EAAE,KAAK,EAAE,CAAC;IACnB,CAAC;IAED,KAAK,CAAC,KAAa,EAAE,WAAgC;QACnD,OAAO,KAAK,KAAK,WAAW,CAAC,KAAK,CAAC;IACrC,CAAC;IAED,SAAS,CAAC,KAAa;QACrB,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED,MAAM,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;AAE9B,MAAM,KAAM,SAAQ,IAAI;IAAxB;;QACW,SAAI,GAAW,OAAO,CAAC;QACvB,iBAAY,GAAY,KAAK,CAAC;QAC9B,WAAM,GAAW,QAAQ,CAAC;IAgBrC,CAAC;IAdC,UAAU,CAAC,QAAgB,EAAE,KAAa;QACxC,4EAA4E;QAC5E,mCAAmC;QACnC,OAAO,EAAE,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,KAAa,EAAE,WAAgC;QACnD,OAAO,cAAc,CAAC,KAAK,CAAC,KAAK,WAAW,CAAC,KAAK,CAAC;IACrD,CAAC;IAED,SAAS,CAAC,KAAa;QACrB,gDAAgD;QAChD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;AAE1B;;GAEG;AACU,QAAA,OAAO,GAAgB;IAClC,GAAG,EAAE,EAAE;IACP,KAAK,EAAE;QACL,MAAM,EAAE,OAAO;QACf,KAAK;KACN;CACF,CAAC;AAEF,gCAAgC","sourcesContent":["/**\n * Implementation of the builtin Relax NG datatype library.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { ParamError, ParameterParsingError, ValueError } from \"./errors\";\nimport { Datatype, ParsedParams, ParsedValue, RawParameter,\n         TypeLibrary } from \"./library\";\n\n/**\n * Strips leading and trailing space. Normalize all internal spaces to a single\n * space.\n *\n * @private\n *\n * @param value The value whose space we want to normalize.\n *\n * @returns The normalized value.\n */\nfunction normalizeSpace(value: string): string {\n  // It is generally faster to trim first.\n  return value.trim().replace(/\\s+/g, \" \");\n}\n\n//\n// TypeScript does not automatically treat unimplemented interface bits as\n// abstract. :-(\n//\n// See https://github.com/Microsoft/TypeScript/issues/4670\n//\nabstract class Base implements Datatype<string> {\n  abstract readonly name: string;\n  abstract readonly needsContext: boolean;\n  abstract readonly regexp: RegExp;\n\n  parseParams(location: string, params?: RawParameter[]): ParsedParams {\n    if (params !== undefined && params.length > 0) {\n      throw new ParameterParsingError(\n        location,\n        [new ParamError(\"this type does not accept parameters\")]);\n    }\n\n    return Object.create(null);\n  }\n\n  abstract parseValue(location: string, value: string): ParsedValue<string>;\n\n  abstract equal(value: string, schemaValue: ParsedValue<string>): boolean;\n\n  abstract disallows(value: string): ValueError[] | false;\n}\n\nclass StringT extends Base {\n  readonly name: \"string\";\n  readonly regexp: RegExp = /^[^]*$/;\n  readonly needsContext: boolean = false;\n\n  parseValue(location: string, value: string): ParsedValue<string> {\n    // The builtins do not disallow anything so we don't call disallows to check\n    // whether the value is disallowed.\n    return { value };\n  }\n\n  equal(value: string, schemaValue: ParsedValue<string>): boolean {\n    return value === schemaValue.value;\n  }\n\n  disallows(value: string): ValueError[] | false {\n    return false;\n  }\n}\n\nconst stringT = new StringT();\n\nclass Token extends Base {\n  readonly name: string = \"token\";\n  readonly needsContext: boolean = false;\n  readonly regexp: RegExp = /^[^]*$/;\n\n  parseValue(location: string, value: string): ParsedValue<string> {\n    // The builtins do not disallow anything so we don't call disallows to check\n    // whether the value is disallowed.\n    return { value: normalizeSpace(value) };\n  }\n\n  equal(value: string, schemaValue: ParsedValue<string>): boolean {\n    return normalizeSpace(value) === schemaValue.value;\n  }\n\n  disallows(value: string): ValueError[] | false {\n    // Yep, token allows anything, just like string.\n    return false;\n  }\n}\n\nconst token = new Token();\n\n/**\n * The builtin datatype library.\n */\nexport const builtin: TypeLibrary = {\n  uri: \"\",\n  types: {\n    string: stringT,\n    token,\n  },\n};\n\n//  LocalWords:  NG MPL unparsed\n"]}