{"version":3,"file":"ref.js","sourceRoot":"","sources":["../../../../../lib/salve/patterns/ref.ts"],"names":[],"mappings":"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","sourcesContent":["import { ElementNameError } from \"../errors\";\nimport { EnterStartTagEvent } from \"../events\";\nimport { ConcreteName } from \"../name_patterns\";\nimport { EndResult, EventSet, InternalFireEventResult, InternalWalker,\n         Pattern } from \"./base\";\nimport { Define } from \"./define\";\nimport { Element } from \"./element\";\n\n/**\n * A pattern for RNG references.\n */\nexport class Ref extends Pattern {\n  private resolvesTo?: Define;\n  /**\n   *\n   * @param xmlPath This is a string which uniquely identifies the\n   * element from the simplified RNG tree. Used in debugging.\n   *\n   * @param name The reference name.\n   */\n  constructor(xmlPath: string, readonly name: string) {\n    super(xmlPath);\n  }\n\n  _prepare(definitions: Map<string, Define>): void {\n    this.resolvesTo = definitions.get(this.name);\n\n    if (this.resolvesTo === undefined) {\n      throw new Error(\"${this.name} cannot be resolved\");\n    }\n  }\n\n  hasEmptyPattern(): boolean {\n    // Refs always contain an element at the top level.\n    return false;\n  }\n\n  get element(): Element {\n    const resolvesTo = this.resolvesTo;\n    if (resolvesTo === undefined) {\n      throw new Error(\"trying to get an element on a ref hat has not been \\\nresolved\");\n    }\n\n    return resolvesTo.pat;\n  }\n\n  newWalker(): InternalWalker {\n    const element = this.element;\n\n    return element.notAllowed ?\n      element.pat.newWalker() :\n      // tslint:disable-next-line:no-use-before-declare\n      new RefWalker(this,\n                    element,\n                    element.name,\n                    new EnterStartTagEvent(element.name),\n                    true,\n                    false);\n  }\n}\n\nexport class RefWalker implements InternalWalker {\n  /**\n   * @param el The pattern for which this walker was constructed.\n   */\n  constructor(protected readonly el: Ref,\n              readonly element: Element,\n              private readonly startName: ConcreteName,\n              private readonly startTagEvent: EnterStartTagEvent,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {}\n\n  clone(): this {\n    return new RefWalker(this.el,\n                         this.element,\n                         this.startName,\n                         this.startTagEvent,\n                         this.canEndAttribute,\n                         this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    return new Set(this.canEnd ? undefined : [this.startTagEvent]);\n  }\n\n  possibleAttributes(): EventSet {\n    return new Set();\n  }\n\n  fireEvent(name: string, params: string[]): InternalFireEventResult {\n    if (!this.canEnd &&\n        (name === \"enterStartTag\" || name === \"startTagAndAttributes\") &&\n        this.startName.match(params[0], params[1])) {\n      this.canEnd = true;\n\n      return new InternalFireEventResult(true, undefined, [this]);\n    }\n\n    return new InternalFireEventResult(false);\n  }\n\n  end(): EndResult {\n    return !this.canEnd ?\n      [new ElementNameError(\"tag required\", this.startName)] : false;\n  }\n\n  endAttributes(): EndResult {\n    return false;\n  }\n}\n"]}