{"version":3,"file":"grammar.js","sourceRoot":"","sources":["../../../../../lib/salve/patterns/grammar.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Pattern and walker for RNG's ``grammar`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { AttributeNameError, ElementNameError,\n         ValidationError } from \"../errors\";\nimport { Name } from \"../name_patterns\";\nimport { NameResolver } from \"../name_resolver\";\nimport { filter, union } from \"../set\";\nimport { TrivialMap } from \"../types\";\nimport { BasePattern, EndResult, EventSet, FireEventResult,\n         InternalFireEventResult, InternalWalker, Pattern } from \"./base\";\nimport { Define } from \"./define\";\nimport { Element } from \"./element\";\nimport { RefWalker } from \"./ref\";\n\n/**\n * Grammar object. Users of this library normally do not create objects of this\n * class themselves but rely on the conversion facilities of salve to create\n * these objects.\n */\nexport class Grammar extends BasePattern {\n  private readonly definitions: Map<string, Define>;\n  private _elementDefinitions: TrivialMap<Element[]>;\n  private _namespaces: Set<string> = new Set();\n  /**\n   * @param xmlPath This is a string which uniquely identifies the\n   * element from the simplified RNG tree. Used in debugging.\n   *\n   * @param start The start pattern of this grammar.\n   *\n   * @param definitions An array which contain all definitions specified in this\n   * grammar.\n   *\n   * @throws {Error} When any definition in the original\n   * schema refers to a schema entity which is not defined in the schema.\n   */\n  constructor(public xmlPath: string, public start: Pattern,\n              definitions?: Define[]) {\n    super(xmlPath);\n\n    const mapInit: [string, Define][] = [];\n    if (definitions !== undefined) {\n      for (const def of definitions) {\n        mapInit.push([def.name, def]);\n      }\n    }\n    this.definitions = new Map(mapInit);\n\n    this._prepare(this.definitions, this._namespaces);\n  }\n\n  /**\n   * Adds a definition.\n   *\n   * @param d The definition to add.\n   */\n  add(d: Define): void {\n    this.definitions.set(d.name, d);\n  }\n\n  get elementDefinitions(): TrivialMap<Element[]> {\n    const ret = this._elementDefinitions;\n    if (ret !== undefined) {\n      return ret;\n    }\n\n    const newDef: TrivialMap<Element[]> =\n      this._elementDefinitions = Object.create(null);\n\n    for (const def of this.definitions.values()) {\n      const el = def.pat;\n      const key = el.name.toString();\n      if (newDef[key] === undefined) {\n        newDef[key] = [el];\n      }\n      else {\n        newDef[key].push(el);\n      }\n    }\n\n    return newDef;\n  }\n\n  /**\n   * @returns ``true`` if the schema is wholly context independent. This means\n   * that each element in the schema can be validated purely on the basis of\n   * knowing its expanded name. ``false`` otherwise.\n   */\n  whollyContextIndependent(): boolean {\n    const defs = this.elementDefinitions;\n    for (const v in defs) {\n      if (defs[v].length > 1) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @returns An array of all namespaces used in the schema.  The array may\n   * contain two special values: ``*`` indicates that there was an ``anyName``\n   * element in the schema and thus that it is probably possible to insert more\n   * than the namespaces listed in the array, ``::except`` indicates that an\n   * ``except`` element is affecting what namespaces are acceptable to the\n   * schema.\n   */\n  getNamespaces(): string[] {\n    return Array.from(this._namespaces);\n  }\n\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n    this.start._prepare(definitions, namespaces);\n    for (const d of this.definitions.values()) {\n      d._prepare(definitions, namespaces);\n    }\n  }\n\n  /**\n   * Creates a new walker to walk this pattern.\n   *\n   * @returns A walker.\n   */\n  newWalker<NR extends NameResolver>(nameResolver: NR): GrammarWalker<NR> {\n    // tslint:disable-next-line:no-use-before-declare\n    return GrammarWalker.make(this, nameResolver);\n  }\n}\n\ninterface IWalker {\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult;\n  canEnd: boolean;\n  canEndAttribute: boolean;\n  end(attribute?: boolean): EndResult;\n  clone(): IWalker;\n  possible(): EventSet;\n}\n\nclass MisplacedElementWalker implements IWalker {\n  canEnd: boolean = true;\n  canEndAttribute: boolean = true;\n\n  fireEvent(name: string, params: string[]): InternalFireEventResult {\n    // The strategy here is to accept everything except for elements.  The lack\n    // of match that occurs on enterStartTag and startTagAndAttributes is\n    // handled elsewhere.\n    switch (name) {\n      case \"enterStartTag\":\n      case \"startTagAndAttributes\":\n        return new InternalFireEventResult(false);\n      default:\n        return new InternalFireEventResult(true);\n    }\n  }\n\n  end(): EndResult {\n    return false;\n  }\n\n  possible(): EventSet {\n    return new Set();\n  }\n\n  clone<T extends this>(this: T): T {\n    return new (this.constructor as new (...args: unknown[]) => T)();\n  }\n}\n\n/**\n * Walker for [[Grammar]].\n */\nexport class GrammarWalker<NR extends NameResolver> {\n  private constructor(protected readonly el: Grammar,\n                      readonly nameResolver: NR,\n                      private elementWalkerStack: IWalker[][],\n                      private misplacedDepth: number,\n                      private _swallowAttributeValue: boolean,\n                      private suspendedWs: string | undefined,\n                      private ignoreNextWs: boolean) {\n  }\n\n  static make<NR extends NameResolver>(el: Grammar,\n                                       nameResolver: NR): GrammarWalker<NR> {\n    return new GrammarWalker(el,\n                             nameResolver,\n                             [[el.start.newWalker()]],\n                             0,\n                             false,\n                             undefined,\n                             false);\n  }\n\n  clone(): this {\n    return new GrammarWalker(this.el,\n                             this.nameResolver.clone(),\n                             this.elementWalkerStack\n                             .map(walkers => walkers.map(x => x.clone())),\n                             this.misplacedDepth,\n                             this._swallowAttributeValue,\n                             this.suspendedWs,\n                             this.ignoreNextWs) as this;\n  }\n\n  /**\n   * On a [[GrammarWalker]] this method cannot return ``undefined``. An\n   * undefined value would mean nothing matched, which is a validation error.\n   *\n   * @param name The event name.\n   *\n   * @param params The event parameters.\n   *\n   * @returns ``false`` if there is no error or an array errors.\n   *\n   * @throws {Error} When trying to process an event type unknown to salve.\n   */\n  fireEvent(name: string, params: string[]): FireEventResult {\n    // Whitespaces are problematic. On the one hand, if an element may contain\n    // only other elements and no text, then XML allows putting whitespace\n    // between the elements. This whitespace must not cause a validation\n    // error. When mixed content is possible, everywhere where text is allowed,\n    // a text of length 0 is possible. (``<text/>`` does not allow specifying a\n    // pattern or minimum length. And Relax NG constraints do not allow having\n    // an element whose content is a mixture of ``element`` and ``data`` and\n    // ``value`` that would constrain specific text patterns between the\n    // elements.) We can satisfy all situations by dropping text events that\n    // contain only whitespace.\n    //\n    // The only case where we'd want to pass a node consisting entirely of\n    // whitespace is to satisfy a data or value pattern because they can require\n    // a sequence of whitespaces.\n    let wsMatch = true;\n    switch (name) {\n      case \"text\": {\n        // Earlier versions of salve processed text events ahead of this switch\n        // block, but we moved it here to improve performance. There's no issue\n        // with having a case for text here because salve disallows firing more\n        // than one text event in sequence.\n        const text = params[0];\n        // Process whitespace nodes\n        if (!/\\S/.test(text)) {\n          if (text === \"\") {\n            throw new Error(\"firing empty text events makes no sense\");\n          }\n\n          // We don't check the old value of suspendedWs because salve does not\n          // allow two text events in a row. So we should never have to\n          // concatenate values.\n          this.suspendedWs = text;\n\n          return false;\n        }\n        break;\n      }\n      case \"endTag\":\n        if (!this.ignoreNextWs && this.suspendedWs !== undefined) {\n          wsMatch = this._fireSuspendedWsOnCurrentWalkers();\n        }\n        this.ignoreNextWs = true;\n        break;\n      default:\n        this.ignoreNextWs = false;\n    }\n    // Absorb the whitespace: poof, gone!\n    this.suspendedWs = undefined;\n\n    // This would happen if the user puts an attribute on a tag that does not\n    // allow one. Instead of generating errors for both the attribute name\n    // and value, we generate an error for the name and ignore the value.\n    if (this._swallowAttributeValue) {\n      // Swallow only one event.\n      this._swallowAttributeValue = false;\n      return name === \"attributeValue\" ? false :\n        [new ValidationError(\"attribute value required\")];\n    }\n\n    const ret = this._fireOnCurrentWalkers(name, params);\n\n    if (name === \"endTag\") {\n      // We do not need to end the walkers because the fireEvent handler\n      // for elements calls end when it sees an \"endTag\" event.\n      // We do not reduce the stack to nothing.\n      if (this.elementWalkerStack.length > 1) {\n        this.elementWalkerStack.pop();\n      }\n\n      if (this.misplacedDepth > 0) {\n        this.misplacedDepth--;\n      }\n    }\n\n    if (ret.matched) {\n      const { refs } = ret;\n      if (refs !== undefined && refs.length !== 0) {\n        this._processRefs(name, refs, params);\n        return false;\n      }\n\n      // There may still have been a problem a problem with the whitespace.\n      return wsMatch ? false : [new ValidationError(\"text not allowed here\")];\n    }\n\n    return ret.errors !== undefined ? ret.errors :\n      this.diagnose(name, params, wsMatch);\n  }\n\n  private diagnose(name: string, params: string[],\n                   wsMatch: boolean): FireEventResult {\n    switch (name) {\n      case \"enterStartTag\":\n      case \"startTagAndAttributes\":\n        // Once in dumb mode, we remain in dumb mode.\n        if (this.misplacedDepth > 0) {\n          this.misplacedDepth++;\n          this.elementWalkerStack.push([new MisplacedElementWalker()]);\n          return wsMatch ? false :\n            [new ValidationError(\"text not allowed here\")];\n        }\n\n        const elName = new Name(params[0], params[1]);\n        // Try to infer what element is meant by this errant tag. If we can't\n        // find a candidate, then fall back to a dumb mode.\n        const candidates = this.el.elementDefinitions[elName.toString()];\n        if (candidates !== undefined && candidates.length === 1) {\n          const newWalker = candidates[0].newWalker(elName);\n          this.elementWalkerStack.push([newWalker]);\n          if (name === \"startTagAndAttributes\") {\n            if (!newWalker.initWithAttributes(params,\n                                              this.nameResolver).matched) {\n              throw new Error(\"internal error: the inferred element \" +\n                              \"does not accept its initial event\");\n            }\n          }\n        }\n        else {\n          // Dumb mode...\n          this.misplacedDepth++;\n          this.elementWalkerStack.push([new MisplacedElementWalker()]);\n        }\n        return [new ElementNameError(\n          name === \"enterStartTag\" ?\n            \"tag not allowed here\" :\n            \"tag not allowed here with these attributes\", elName)];\n      case \"endTag\":\n        return [new ElementNameError(\"unexpected end tag\",\n                                     new Name(params[0], params[1]))];\n      case \"attributeName\":\n        this._swallowAttributeValue = true;\n        return [new AttributeNameError(\"attribute not allowed here\",\n                                       new Name(params[0], params[1]))];\n      case \"attributeNameAndValue\":\n        return [new AttributeNameError(\"attribute not allowed here\",\n                                       new Name(params[0], params[1]))];\n      case \"attributeValue\":\n        return [new ValidationError(\"unexpected attributeValue event; it \\\nis likely that fireEvent is incorrectly called\")];\n      case \"text\":\n        return [new ValidationError(\"text not allowed here\")];\n      case \"leaveStartTag\":\n        // If MisplacedElementWalker did not exist then we would get here if a\n        // file being validated contains a tag which is not allowed. But it\n        // exists, so we cannot get here. If we do end up here, then there is\n        // an internal error somewhere.\n        /* falls through */\n      default:\n        throw new Error(`unexpected event type in GrammarWalker's fireEvent: \\\n${name}`);\n    }\n  }\n\n  // A text event either matches or does not match. It does not generate by\n  // itself an error. So we do not track errors in this specialized function,\n  // nor do we track references.\n  private _fireSuspendedWsOnCurrentWalkers(): boolean {\n    const { elementWalkerStack } = this;\n    const last = elementWalkerStack.length - 1;\n    const walkers = elementWalkerStack[last];\n\n    // Checking whether walkers.length === 0 would not be a particularly useful\n    // optimization, as we don't let that happen.\n\n    // This optimization for the single walker case is significant.\n    if (walkers.length === 1) {\n      return walkers[0].fireEvent(\"text\", [this.suspendedWs!],\n                                  this.nameResolver).matched;\n    }\n\n    const params = [this.suspendedWs!];\n    const remainingWalkers: IWalker[] = [];\n    for (const walker of walkers) {\n      const result = walker.fireEvent(\"text\", params, this.nameResolver);\n      // We immediately filter out results that report a match (i.e. false).\n      if (result.matched) {\n        remainingWalkers.push(walker);\n      }\n    }\n\n    // We don't remove all walkers. If some walkers were successful and some\n    // were not, then we just keep the successful ones. But removing all walkers\n    // at once prevents us from giving useful error messages.\n    if (remainingWalkers.length !== 0) {\n      elementWalkerStack[last] = remainingWalkers;\n      return true;\n    }\n\n    return false;\n  }\n\n  private _fireOnCurrentWalkers(name: string,\n                                params: string[]): InternalFireEventResult {\n    const { elementWalkerStack } = this;\n    const last = elementWalkerStack.length - 1;\n    const walkers = elementWalkerStack[last];\n\n    // Checking whether walkers.length === 0 would not be a particularly useful\n    // optimization, as we don't let that happen.\n\n    // This optimization for the single walker case is significant.\n    if (walkers.length === 1) {\n      return walkers[0].fireEvent(name, params, this.nameResolver);\n    }\n\n    const errors: ValidationError[] = [];\n    const refs: RefWalker[] = [];\n    const remainingWalkers: IWalker[] = [];\n    for (const walker of walkers) {\n      const result = walker.fireEvent(name, params, this.nameResolver);\n      // We immediately filter out results that report a match (i.e. false).\n      if (result.matched) {\n        remainingWalkers.push(walker);\n        if (result.refs !== undefined) {\n          refs.push(...result.refs);\n        }\n      }\n      // There's no point in recording errors if we're going to toss them\n      // anyway.\n      else if ((remainingWalkers.length === 0) &&\n               (result.errors !== undefined)) {\n        errors.push(...result.errors);\n      }\n    }\n\n    // We don't remove all walkers. If some walkers were successful and some\n    // were not, then we just keep the successful ones. But removing all walkers\n    // at once prevents us from giving useful error messages.\n    if (remainingWalkers.length !== 0) {\n      elementWalkerStack[last] = remainingWalkers;\n\n      // If some of the walkers matched, we ignore the errors from the other\n      // walkers.\n      return new InternalFireEventResult(true, undefined,\n                                         refs.length !== 0 ? refs : undefined);\n    }\n\n    return new InternalFireEventResult(false,\n                                       errors.length !== 0 ? errors :\n                                       undefined);\n  }\n\n  private _processRefs(name: string, refs: readonly RefWalker[],\n                       params: string[]): void {\n    const newWalkers: InternalWalker[] = [];\n    const boundName = new Name(params[0], params[1]);\n    if (name === \"startTagAndAttributes\") {\n      for (const item of refs) {\n        const walker = item.element.newWalker(boundName);\n        // If we get anything else than false here, the internal logic is\n        // wrong.\n        if (!walker.initWithAttributes(params, this.nameResolver).matched) {\n          throw new Error(\"error or failed to match on a new element \\\nwalker: the internal logic is incorrect\");\n        }\n        newWalkers.push(walker);\n      }\n    }\n    else {\n      for (const item of refs) {\n        newWalkers.push(item.element.newWalker(boundName));\n      }\n    }\n\n    this.elementWalkerStack.push(newWalkers);\n  }\n\n  canEnd(): boolean {\n    const top = this.elementWalkerStack[this.elementWalkerStack.length - 1];\n\n    return this.elementWalkerStack.length === 1 &&\n      top.length > 0 && top[0].canEnd;\n  }\n\n  end(): EndResult {\n    if (this.elementWalkerStack.length < 1) {\n      throw new Error(\"stack underflow\");\n    }\n\n    let finalResult: ValidationError[] = [];\n    for (let ix = this.elementWalkerStack.length - 1; ix >= 0; --ix) {\n      const stackElement = this.elementWalkerStack[ix];\n      for (const walker of stackElement) {\n        const result = walker.end();\n        if (result) {\n          finalResult = finalResult.concat(result);\n        }\n      }\n    }\n\n    return finalResult.length !== 0 ? finalResult : false;\n  }\n\n  possible(): EventSet {\n    let possible: EventSet = new Set();\n    for (const walker of\n         this.elementWalkerStack[this.elementWalkerStack.length - 1]) {\n      union(possible, walker.possible());\n    }\n\n    // If we have any attributeValue possible, then the only possible\n    // events are attributeValue events.\n    if (possible.size !== 0) {\n      const valueEvs =\n        filter(possible, ({ name }) => name === \"attributeValue\");\n\n      if (valueEvs.size !== 0) {\n        possible = valueEvs;\n      }\n    }\n\n    return possible;\n  }\n}\n\n//  LocalWords:  RNG's MPL unresolvable runtime RNG NG firstName enterContext\n//  LocalWords:  leaveContext definePrefix whitespace enterStartTag endTag\n//  LocalWords:  fireEvent attributeValue attributeName leaveStartTag\n//  LocalWords:  misplacedElements ElementNameError GrammarWalker's\n//  LocalWords:  suppressAttributes GrammarWalker\n"]}