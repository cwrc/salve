{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../../lib/salve/patterns/base.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Classes that model RNG patterns.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { ValidationError } from \"../errors\";\nimport { Events } from \"../events\";\nimport { NameResolver } from \"../name_resolver\";\nimport { Define } from \"./define\";\nimport { Element } from \"./element\";\nimport { RefWalker } from \"./ref\";\n\n// XML validation against a schema could work without any lookahead if it were\n// not for namespaces. However, namespace support means that the interpretation\n// of a tag or of an attribute may depend on information which appears *later*\n// than the earliest time at which a validation decision might be called for:\n//\n// Consider:\n//    <elephant a=\"a\" b=\"b\"... xmlns=\"elephant_uri\"/>\n//\n// It is not until xmlns is encountered that the validator will know that\n// elephant belongs to the elephant_uri namespace. This is not too troubling for\n// a validator that can access the whole document but for validators used in a\n// line-by-line process (which is the case if the validator is driven by a\n// CodeMirror or Ace tokenizer, and anything based on them), this can be\n// problematic because the attributes could appear on lines other than the line\n// on which the start of the tag appears:\n//\n// <elephant\n//  a=\"a\"\n//  b=\"b\"\n//  xmlns=\"elephant_uri\"/>\n//\n// The validator encounters the start of the tag and the attributes, without\n// knowing that eventually this elephant tag belongs to the elephant_uri\n// namespace. This discovery might result in things that were seen previously\n// and deemed valid becoming invalid. Or things that were invalid becoming\n// valid.\n//\n// Handling namespaces will require lookahead. Although the validator would\n// still expect all events that have tag and attribute names to have a proper\n// namespace uri, upon ``enterStartTag`` the parsing code which feeds events to\n// the validator would look ahead for these cases:\n//\n// * There is a valid ``>`` character ending the start tag. Scan the start tag\n//   for all namespace declarations.\n//\n// * The tag ends at EOF. Scan from beginning of tag to EOF for namespace\n//   declarations.\n//\n// * The tag is terminated by an invalid token. Scan from beginning of tag to\n//   error.\n//\n// Then issue the enterStartTag and attributeName events on the basis of what\n// was found in scanning.\n//\n// When the parsing code discovers a change in namespace declarations, for\n// instance because the user typed xmlns=\"...\" or removed a declaration, the\n// parsing code must *restart* validation *from* the location of the original\n// enterStartTag event.\n\nexport type EventSet = Set<Events>;\n\nexport type FireEventResult = false | undefined | readonly ValidationError[];\n\nexport class InternalFireEventResult {\n  constructor(readonly matched: boolean,\n              readonly errors?: ReadonlyArray<ValidationError>,\n              readonly refs?: ReadonlyArray<RefWalker>) {}\n\n  static fromEndResult(result: EndResult): InternalFireEventResult {\n    return (result === false) ?\n      new InternalFireEventResult(true) :\n      new InternalFireEventResult(false, result);\n  }\n\n  combine(other: InternalFireEventResult): InternalFireEventResult {\n    if (this.matched) {\n      const { refs } = this;\n      const oRefs = other.refs;\n      return oRefs === undefined ?\n        this :\n        new InternalFireEventResult(true, undefined,\n                                    refs === undefined ? oRefs :\n                                    refs.concat(oRefs));\n    }\n\n    const { errors } = this;\n    const oErrors = other.errors;\n    return oErrors === undefined ?\n      this :\n      new InternalFireEventResult(false,\n                                  errors === undefined ? oErrors :\n                                  errors.concat(oErrors),\n                                  undefined);\n  }\n}\n\nexport type EndResult = false | ValidationError[];\n\n/**\n * These patterns form a JavaScript representation of the simplified RNG\n * tree. The base class implements a leaf in the RNG tree. In other words, it\n * does not itself refer to children Patterns. (To put it in other words, it has\n * no subpatterns.)\n */\nexport class BasePattern {\n  readonly xmlPath: string;\n\n  /**\n   * @param xmlPath This is a string which uniquely identifies the element from\n   * the simplified RNG tree. Used in debugging.\n   */\n  constructor(xmlPath: string) {\n    this.xmlPath = xmlPath;\n  }\n\n  /**\n   * This method must be called after resolution has been performed.\n   * ``_prepare`` recursively calls children but does not traverse ref-define\n   * boundaries to avoid infinite regress...\n   *\n   * This function now performs these tasks:\n   *\n   * - it precomputes the values returned by ``hasAttr``,\n   *\n   * - it precomputes the values returned by ``hasEmptyPattern``,\n   *\n   * - it gathers all the namespaces seen in the schema.\n   *\n   * - it resolves the references.\n   *\n   * @param definitions The definitions present in the schema.\n   *\n   * @param namespaces An object whose keys are the namespaces seen in\n   * the schema. This method populates the object.\n   */\n  // tslint:disable-next-line:no-empty\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n  }\n\n  /**\n   * This method tests whether a pattern is an attribute pattern or contains\n   * attribute patterns. This method does not cross element boundaries. That is,\n   * if element X cannot have attributes of its own but can contain elements\n   * that can have attributes, the return value if this method is called on the\n   * pattern contained by element X's pattern will be ``false``.\n   *\n   * @returns True if the pattern is or has attributes. False if not.\n   */\n  hasAttrs(): boolean {\n    return false;\n  }\n\n  /**\n   * This method determines whether a pattern has the ``empty``\n   * pattern. Generally, this means that either this pattern is the ``empty``\n   * pattern or has ``empty`` as a child.\n   */\n  hasEmptyPattern(): boolean {\n    return false;\n  }\n}\n\n/**\n * This is the common class from which patterns are derived. Most patterns\n * create a new walker by passing a name resolver. The one exception is\n * [[Grammar]], which creates the name resolver that are used by other\n * patterns. So when calling it we do not need a ``resolver`` parameter and thus\n * it inherits from [[BasePattern]] rather than [[Pattern]].\n */\nexport abstract class Pattern extends BasePattern {\n  /**\n   * Creates a new walker to walk this pattern.\n   *\n   * @returns A walker.\n   */\n  newWalker(): InternalWalker {\n    // Rather than make it abstract, we provide a default implementation for\n    // this method, which throws an exception if called. We could probably\n    // reorganize the code to do without but a) we would not gain much b) it\n    // would complicate the type hierarchy. The cost is not worth the\n    // benefits. There are two patterns that land on this default implementation\n    // and neither can have newWalker called on them anyway.\n    throw new Error(\"derived classes must override this\");\n  }\n}\n\n/**\n * Pattern objects of this class have exactly one child pattern.\n */\nexport abstract class OneSubpattern<T extends (Pattern | Element) = Pattern>\n  extends Pattern {\n  protected _cachedHasAttrs?: boolean;\n  protected _cachedHasEmptyPattern?: boolean;\n\n  constructor(xmlPath: string, readonly pat: T) {\n    super(xmlPath);\n  }\n\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n    this.pat._prepare(definitions, namespaces);\n    this._cachedHasAttrs = this.pat.hasAttrs();\n    this._cachedHasEmptyPattern = this.pat.hasEmptyPattern();\n  }\n\n  hasAttrs(): boolean {\n    // tslint:disable-next-line:no-non-null-assertion\n    return this._cachedHasAttrs!;\n  }\n\n  hasEmptyPattern(): boolean {\n    // tslint:disable-next-line:no-non-null-assertion\n    return this._cachedHasEmptyPattern!;\n  }\n}\n\n/**\n * Pattern objects of this class have exactly two child patterns.\n *\n */\nexport abstract class TwoSubpatterns extends Pattern {\n  protected _cachedHasAttrs?: boolean;\n  protected _cachedHasEmptyPattern?: boolean;\n\n  constructor(xmlPath: string, readonly patA: Pattern, readonly patB: Pattern) {\n    super(xmlPath);\n  }\n\n  protected abstract _computeHasEmptyPattern(): boolean;\n\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n    this.patA._prepare(definitions, namespaces);\n    this.patB._prepare(definitions, namespaces);\n    this._cachedHasAttrs = this.patA.hasAttrs() || this.patB.hasAttrs();\n    this._cachedHasEmptyPattern = this._computeHasEmptyPattern();\n  }\n\n  hasAttrs(): boolean {\n    // tslint:disable-next-line:no-non-null-assertion\n    return this._cachedHasAttrs!;\n  }\n\n  hasEmptyPattern(): boolean {\n    // tslint:disable-next-line:no-non-null-assertion\n    return this._cachedHasEmptyPattern!;\n  }\n}\n\nexport function isAttributeEvent(name: string): boolean {\n  return name === \"attributeName\" || name === \"attributeValue\" ||\n    name === \"attributeNameAndValue\";\n}\n\ninterface NodeMap extends Map<string, false | NodeMap> {}\n\n/**\n * Utility function used mainly in testing to transform a set of\n * events into a string containing a tree structure.  The principle is to\n * combine events of a same type together and among events of a same type\n * combine those which are in the same namespace. So for instance if there is a\n * set of events that are all attributeName events plus one ``leaveStartTag``\n * event, the output could be:\n *\n * <pre>``\n * attributeName:\n * ..uri A:\n * ....name 1\n * ....name 2\n * ..uri B:\n * ....name 3\n * ....name 4\n * leaveStartTag\n * ``</pre>\n *\n * The dots above are to represent more visually the indentation. Actual output\n * does not contain leading dots.  In this list there are two attributeName\n * events in the \"uri A\" namespace and two in the \"uri B\" namespace.\n *\n * @param evs Events to turn into a string.\n * @returns A string which contains the tree described above.\n */\nexport function eventsToTreeString(evs: Events[] | EventSet): string {\n  const eventArray = evs instanceof Set ? Array.from(evs) : evs;\n\n  const hash: NodeMap = new Map<string, false | NodeMap>();\n  for (const { name, param } of eventArray) {\n    if (param !== null) {\n      let nextNode = hash.get(name) as NodeMap | undefined;\n      if (nextNode === undefined) {\n        nextNode = new Map<string, false | NodeMap>();\n        hash.set(name, nextNode);\n      }\n      nextNode.set(param.toString(), false);\n    }\n    else {\n      hash.set(name, false);\n    }\n  }\n\n  function dumpTree(toDump: NodeMap, indent: string): string {\n    let ret = \"\";\n    const keys = Array.from(toDump.keys());\n    keys.sort();\n    for (const key of keys) {\n      // tslint:disable-next-line:no-non-null-assertion\n      const sub = toDump.get(key)!;\n      if (sub !== false) {\n        ret += `${indent}${key}:\\n`;\n        ret += dumpTree(sub, `${indent}    `);\n      }\n      else {\n        ret += `${indent}${key}\\n`;\n      }\n    }\n\n    return ret;\n  }\n\n  return dumpTree(hash, \"\");\n  /* tslint:enable */\n}\n\n/**\n * This is the class of all walkers that are used internally to Salve.\n */\nexport interface InternalWalker {\n  /**\n   * Passes an event to the walker for handling. The Walker will determine\n   * whether it or one of its children can handle the event.\n   *\n   * @param name The event name.\n   *\n   * @param params The event parameters.\n   *\n   * @param nameResolver The name resolver to use to resolve names.\n   *\n   * @returns The value ``false`` if there was no error. The value ``undefined``\n   * if no walker matches the pattern. Otherwise, an array of\n   * [[ValidationError]] objects.\n   */\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult;\n\n  /**\n   * Flag indicating whether the walker can end.\n   */\n  canEnd: boolean;\n\n  /**\n   * Flag indicating whether the walker can end, in a context where\n   * we are processing attributes.\n   */\n  canEndAttribute: boolean;\n\n  /**\n   * @returns The set of non-attribute event that can be fired without resulting\n   * in an error. ``ElementWalker`` exceptionally returns all possible events,\n   * including attribute events.\n   */\n  possible(): EventSet;\n\n  /**\n   * @returns The set of attribute events that can be fired without resulting in\n   * an error. This method may not be called on ``ElementWalker``.\n   */\n  possibleAttributes(): EventSet;\n\n  /**\n   * End the walker.\n   *\n   * @returns ``false`` if the walker ended without error. Otherwise, the\n   * errors.\n   */\n  end(): EndResult;\n\n  /**\n   * End the processing of attributes.\n   *\n   * @returns ``false`` if the walker ended without error. Otherwise, the\n   * errors.\n   */\n  endAttributes(): EndResult;\n\n  /**\n   * Deep copy the Walker.\n   *\n   * @returns A deep copy of the Walker.\n   */\n  clone(): this;\n}\n\n//  LocalWords:  RNG MPL lookahead xmlns uri CodeMirror tokenizer enterStartTag\n//  LocalWords:  EOF attributeName el xmlPath buf nameOrPath util ret EventSet\n//  LocalWords:  NameResolver args unshift HashSet subpatterns newID NG vm pre\n//  LocalWords:  firstName lastName attributeValue leaveStartTag dumpTree const\n//  LocalWords:  dumpTreeBuf subwalker fireEvent suppressAttributes HashMap\n//  LocalWords:  ValidationError RefWalker DefineWalker\n"]}