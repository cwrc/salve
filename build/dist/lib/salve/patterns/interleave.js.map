{"version":3,"file":"interleave.js","sourceRoot":"","sources":["../../../../../lib/salve/patterns/interleave.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Pattern and walker for RNG's ``interleave`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { NameResolver } from \"../name_resolver\";\nimport { union } from \"../set\";\nimport { EndResult, EventSet, InternalFireEventResult, InternalWalker,\n         isAttributeEvent, TwoSubpatterns } from \"./base\";\n\n/**\n * A pattern for ``<interleave>``.\n */\nexport class Interleave extends TwoSubpatterns {\n  protected _computeHasEmptyPattern(): boolean {\n    return this.patA.hasEmptyPattern() && this.patB.hasEmptyPattern();\n  }\n\n  newWalker(): InternalWalker {\n    const hasAttrs = this.hasAttrs();\n    const walkerA = this.patA.newWalker();\n    const walkerB = this.patB.newWalker();\n\n    // tslint:disable-next-line:no-use-before-declare\n    return new InterleaveWalker(this,\n                                walkerA,\n                                walkerB,\n                                hasAttrs,\n                                false,\n                                !hasAttrs || (walkerA.canEndAttribute &&\n                                              walkerB.canEndAttribute),\n                                walkerA.canEnd && walkerB.canEnd);\n  }\n}\n\n/**\n * Walker for [[Interleave]].\n */\nclass InterleaveWalker implements InternalWalker {\n  constructor(protected readonly el: Interleave,\n              private readonly walkerA: InternalWalker,\n              private readonly walkerB: InternalWalker,\n              private readonly hasAttrs: boolean,\n              private ended: boolean,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {}\n\n  clone(): this {\n    return new InterleaveWalker(this.el,\n                                this.walkerA.clone(),\n                                this.walkerB.clone(),\n                                this.hasAttrs,\n                                this.ended,\n                                this.canEndAttribute,\n                                this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    if (this.ended) {\n      return new Set();\n    }\n\n    const ret = this.walkerA.possible();\n    union(ret, this.walkerB.possible());\n\n    return ret;\n  }\n\n  possibleAttributes(): EventSet {\n    if (this.ended) {\n      return new Set();\n    }\n\n    const ret = this.walkerA.possibleAttributes();\n    union(ret, this.walkerB.possibleAttributes());\n\n    return ret;\n  }\n\n  //\n  // Interleave is very unusual among the patterns due to the fact that it\n  // ignores subpattern order. For instance\n  //\n  // <interleave>A<interleave>B C</interleave></interleave>\n  //\n  // can match any permutation of the patterns A B and C. In particular, the\n  // sequence B A C needs to be handled by the inner interleave, then by the\n  // pattern for A and then by the inner interleave again.\n  //\n  // Moreover, while validating, it may match subpatterns only partially.\n  // For instance:\n  //\n  // <interleave><group>A B</group>C</interleave>\n  //\n  // will match all permutations of A B C where A appears before B (so A B C, A\n  // C B and C A B). The sequence A C B is particularly problematic as it means\n  // matching the inner group, then matching C, then going back to the inner\n  // group!\n  //\n  // When an interleave subpattern starts to match, we may not switch to\n  // another subpattern until that subpattern is done. However, \"done\" here is\n  // not synonymous with ``canEnd === true``. Looking again at the B A C\n  // scenario above, we can switch to A when B is done but the inner level\n  // interleave is itself not \"done\" because C has not matched yet.\n  //\n  // We work around the issue by counting the number of start tags and end tags\n  // seen by a pattern. When they are equal we can switch away from from the\n  // pattern to another one.\n  //\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    if (!this.hasAttrs && isAttributeEvent(name)) {\n      return new InternalFireEventResult(false);\n    }\n\n    //\n    // fireEvent is not called after ended is true\n    // if (this.ended) {\n    //   return new InternalFireEventResult(false);\n    // }\n    //\n\n    const { walkerA, walkerB } = this;\n\n    const retA = walkerA.fireEvent(name, params, nameResolver);\n    if (retA.matched) {\n      this.canEndAttribute = walkerA.canEndAttribute && walkerB.canEndAttribute;\n      this.canEnd = walkerA.canEnd && walkerB.canEnd;\n\n      // The constraints on interleave do not allow for two child patterns of\n      // interleave to match. So if the first walker matched, the second\n      // cannot. So we don't have to fireEvent on the second walker if the\n      // first matched.\n      return retA;\n    }\n\n    const retB = walkerB.fireEvent(name, params, nameResolver);\n    if (retB.matched) {\n      this.canEndAttribute =\n        walkerA.canEndAttribute && walkerB.canEndAttribute;\n      this.canEnd = walkerA.canEnd && walkerB.canEnd;\n\n      return retB;\n    }\n\n    return new InternalFireEventResult(false);\n  }\n\n  end(): EndResult {\n    if (this.ended) {\n      return false;\n    }\n\n    if (this.canEnd) {\n      this.ended = true;\n\n      return false;\n    }\n\n    const retA = this.walkerA.end();\n    const retB = this.walkerB.end();\n\n    if (retA) {\n      return !retB ? retA : retA.concat(retB);\n    }\n\n    return retB;\n  }\n\n  endAttributes(): EndResult {\n    if (this.canEndAttribute) {\n      return false;\n    }\n\n    const retA = this.walkerA.endAttributes();\n    const retB = this.walkerB.endAttributes();\n\n    if (retA) {\n      return retB ? retA.concat(retB) : retA;\n    }\n\n    return retB;\n  }\n}\n\n//  LocalWords:  RNG's MPL NG inA inB instantiateWalkers fireEvent retA retB\n"]}