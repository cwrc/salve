{"version":3,"file":"element.js","sourceRoot":"","sources":["../../../../../lib/salve/patterns/element.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Pattern and walker for RNG's ``element`` elements.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { ElementNameError } from \"../errors\";\nimport { EndTagEvent, LeaveStartTagEvent } from \"../events\";\nimport { ConcreteName, Name } from \"../name_patterns\";\nimport { NameResolver } from \"../name_resolver\";\nimport { BasePattern, EndResult, EventSet, InternalFireEventResult,\n         InternalWalker, Pattern } from \"./base\";\nimport { Define } from \"./define\";\nimport { NotAllowed } from \"./not_allowed\";\n\nexport interface Initializable {\n  initWithAttributes(attrs: string[],\n                     nameResolver: NameResolver): InternalFireEventResult;\n}\n\n/**\n * A pattern for elements.\n */\nexport class Element extends BasePattern {\n  readonly notAllowed: boolean;\n\n  /**\n   * @param xmlPath This is a string which uniquely identifies the\n   * element from the simplified RNG tree. Used in debugging.\n   *\n   * @param name The qualified name of the element.\n   *\n   * @param pat The pattern contained by this one.\n   */\n  constructor(xmlPath: string, readonly name: ConcreteName,\n              readonly pat: Pattern) {\n    super(xmlPath);\n    this.notAllowed = pat instanceof NotAllowed;\n  }\n\n  newWalker(boundName: Name): InternalWalker & Initializable {\n    // tslint:disable-next-line:no-use-before-declare\n    return new ElementWalker(this,\n                             this.pat.hasAttrs(),\n                             this.pat.newWalker(),\n                             false,\n                             new EndTagEvent(boundName),\n                             boundName,\n                             true,\n                             false);\n  }\n\n  hasAttrs(): boolean {\n    return false;\n  }\n\n  hasEmptyPattern(): boolean {\n    // The question is whether an element allows empty content **in the context\n    // in which it appears**, not empty content inside it. So the answer is\n    // always negative.\n    return false;\n  }\n\n  _prepare(definitions: Map<string, Define>, namespaces: Set<string>): void {\n    this.name._recordNamespaces(namespaces, true);\n    this.pat._prepare(definitions, namespaces);\n  }\n}\n\n/**\n *\n * Walker for [[Element]].\n */\nclass ElementWalker implements InternalWalker, Initializable {\n  private static _leaveStartTagEvent: LeaveStartTagEvent =\n    new LeaveStartTagEvent();\n\n  constructor(protected readonly el: Element,\n              private readonly hasAttrs: boolean,\n              private readonly walker: InternalWalker,\n              private endedStartTag: boolean,\n              private readonly endTagEvent: EndTagEvent,\n              private boundName: Name,\n              public canEndAttribute: boolean,\n              public canEnd: boolean) {}\n\n  clone(): this {\n    return new ElementWalker(this.el,\n                             this.hasAttrs,\n                             this.walker.clone(),\n                             this.endedStartTag,\n                             this.endTagEvent,\n                             this.boundName,\n                             this.canEndAttribute,\n                             this.canEnd) as this;\n  }\n\n  possible(): EventSet {\n    // Contrarily to all other implementations, which must only return\n    // non-attribute events. This implementation actually returns all types of\n    // possible events. Representing this distinction through TS type\n    // declarations would be cumbersome. The exception works because of the way\n    // Relax NG constrains the structure of a simplified schema. The only\n    // possible caller for this method is ``GrammarWalker``, which also aims to\n    // return all possible events.\n\n    if (!this.endedStartTag) {\n      const walker = this.walker;\n\n      const ret = walker.possibleAttributes();\n\n      if (walker.canEndAttribute) {\n        ret.add(ElementWalker._leaveStartTagEvent);\n      }\n\n      return ret;\n    }\n    else if (!this.canEnd) {\n      const walker = this.walker;\n      const posses = walker.possible();\n      if (walker.canEnd) {\n        posses.add(this.endTagEvent);\n      }\n\n      return posses;\n    }\n\n    return new Set();\n  }\n\n  possibleAttributes(): EventSet {\n    throw new Error(\"calling possibleAttributes on ElementWalker is invalid\");\n  }\n\n  /**\n   * Initialize this walker with initial attributes. This is provided to support\n   * ``startTagAndAttributes``.\n   *\n   * @param params The **entire** list of parameters passed with the\n   * ``startTagAndAttributes`` event.\n   *\n   * @param nameResolver The name resolver to use to resolve names.\n   *\n   * @returns The result of firing all the events for the attributes.\n   */\n  initWithAttributes(params: string[],\n                     nameResolver: NameResolver): InternalFireEventResult {\n    const { walker } = this;\n    // We need to handle all attributes and leave the start tag.\n    for (let ix = 2; ix < params.length; ix += 3) {\n      const attrRet = walker.fireEvent(\"attributeNameAndValue\",\n                                       [params[ix], params[ix + 1],\n                                        params[ix + 2]], nameResolver);\n      if (!attrRet.matched) {\n        return attrRet;\n      }\n    }\n\n    // Make leaveStartTag effective.\n    this.endedStartTag = true;\n\n    return this.hasAttrs ?\n      InternalFireEventResult.fromEndResult(walker.endAttributes()) :\n      new InternalFireEventResult(true);\n  }\n\n  fireEvent(name: string, params: string[],\n            nameResolver: NameResolver): InternalFireEventResult {\n    // This is not a useful optimization. canEnd becomes true once we see\n    // the end tag, which means that this walker will be popped of\n    // GrammarWalker's stack and won't be called again.\n    //\n    // if (this.canEnd) {\n    //   return undefined;\n    // }\n\n    const walker = this.walker;\n    if (this.endedStartTag) {\n      if (name === \"endTag\") {\n        // We cannot get here if canEnd is already true. So this will\n        // necessarily leave it false or set it to true but it won't set a true\n        // canEnd back to false.\n        this.canEnd = this.boundName.match(params[0], params[1]);\n\n        return InternalFireEventResult.fromEndResult(walker.end());\n      }\n\n      return walker.fireEvent(name, params, nameResolver);\n    }\n\n    if (name === \"leaveStartTag\") {\n      this.endedStartTag = true;\n\n      return this.hasAttrs ?\n        InternalFireEventResult.fromEndResult(walker.endAttributes()) :\n        new InternalFireEventResult(true);\n    }\n\n    return walker.fireEvent(name, params, nameResolver);\n  }\n\n  end(): EndResult {\n    if (this.canEnd) {\n      return false;\n    }\n\n    const err = new ElementNameError(this.endedStartTag ?\n                                     \"tag not closed\" :\n                                     \"start tag not terminated\",\n                                     this.boundName);\n    const walkerRet = this.walker.end();\n\n    return walkerRet ? walkerRet.concat(err) : [err];\n  }\n\n  endAttributes(): EndResult {\n    throw new Error(\"calling endAttributes on ElementWalker is illegal\");\n  }\n}\n\n//  LocalWords:  RNG's MPL RNG ElementWalker leaveStartTag valueEvs\n//  LocalWords:  enterStartTag attributeValue endTag errored subwalker\n//  LocalWords:  neutralizeAttribute boundName fireEvent suppressAttributes\n"]}