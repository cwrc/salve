{"version":3,"file":"library.js","sourceRoot":"","sources":["../../../../../lib/salve/datatypes/library.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAmJH,uBAAuB","sourcesContent":["/**\n * Definition of the types that form a type library.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n * @private\n */\n\nimport { NameResolver } from \"../name_resolver\";\nimport { TrivialMap } from \"../types\";\nimport { ValueError } from \"./errors\";\n\n/**\n * A \"raw\" parameter taken straight from the Relax NG.\n */\nexport type RawParameter = {\n  /**\n   * The parameter's name.\n   */\n  name: string;\n  /**\n   * It's value.\n   */\n  value: string;\n};\n\n/**\n * A context as defined by the Relax NG specification, minus the base URI.  (Why\n * no base URI? Because none of the types implemented by salve require it. So\n * there is no point in keeping track of it.)\n */\nexport interface Context {\n  /**\n   * A name resolver that can resolve namespace prefixes to namespace URI.\n   */\n  resolver: NameResolver;\n}\n\nexport interface ParsedValue<T> {\n  value: T;\n}\n\nexport type ParsedParams = TrivialMap<string[]|number>;\n\n/**\n * A schema data type.\n */\nexport interface Datatype<T = {}> {\n  /**\n   * The name of this type.\n   */\n  readonly name: string;\n\n  /**\n   * ``true`` if this builtin type needs a context, ``false`` if not.\n   */\n  readonly needsContext: boolean;\n\n  /**\n   * A JavaScript regular expression which can be used to partially validate a\n   * value. This regular expression is such that if it does *not* match a value,\n   * then the value is invalid. If it does match the value, then [[disallows]]\n   * must be called to determine whether the value is actually allowed or not.\n   *\n   * Note that this regular expression must take into account the whitespace\n   * processing required by the datatype, because this processing occurs before\n   * determining whether a value is part of the lexical space of a type.\n   */\n  readonly regexp: RegExp;\n\n  /**\n   * Parses the parameters. It can be called without any parameters for the\n   * purpose of computing the default parameters of a datatype.\n   *\n   * @param location A string indicating the location of the ``<data>``\n   * element for which we are parsing parameters.\n   *\n   * @param params The parameters.\n   *\n   * @returns The parsed parameters, to be used with the other methods on this\n   * class. Data types are free to change the format of this object at any time.\n   *\n   * @throws {\"datatypes\".ParameterParsingError} If the parameters are\n   * erroneous.\n   */\n  parseParams(location: string, params?: RawParameter[]): ParsedParams;\n\n  /**\n   * Parses a value. Checks that the value is allowed by the type and converts\n   * it to an internal representation.\n   *\n   * @param location: A string indicating the location of the ``<value>``\n   * element for which we are parsing a value.\n   *\n   * @param value The value to parse.\n   *\n   * @param context The context of the value.\n   *\n   * @returns The parsed value, to be used with the other methods on this\n   * class. Data types are free to change the format of this object at any time.\n   *\n   * @throws {\"datatypes\".ValueValidationError} If the value is\n   * erroneous.\n   */\n  parseValue(location: string, value: string,\n             context?: Context): ParsedValue<T>;\n\n  /**\n   * Checks whether two strings are equal according to the type.\n   *\n   * @param value The string from the XML document to be validated.\n   *\n   * @param schemaValue The **parsed** value from the schema.\n   *\n   * @param context The context in the document, if needed.\n   *\n   * @returns ``true`` if equal, ``false`` if not.\n   */\n  equal(value: string, schemaValue: ParsedValue<T>,\n        context?: Context): boolean;\n\n  /**\n   * Checks whether the type disallows a certain string.\n   *\n   * @param value The string from the XML document to be validated.\n   *\n   * @param params The type parameters. These must be **parsed** already.\n   *\n   * @param context The context in the document, if needed. **Note**: this\n   * method must accept being called without a context *even if it normally\n   * requires a context* when the a ``value`` is set to the empty string. This\n   * allows determining ahead of XML validation whether an empty string is\n   * allowed.\n   *\n   * @returns ``false`` if not disallowed. Otherwise, the errors caused by the\n   * value.\n   */\n  disallows(value: string, params: ParsedParams,\n            context?: Context): ValueError[] | false;\n}\n\nexport interface TypeLibrary {\n  /**\n   * The URI associated with this library.\n   */\n  readonly uri: string;\n\n  /**\n   * A mapping of name to type covering all the types in this library.\n   */\n  readonly types: { [name: string]: Datatype };\n}\n\n//  LocalWords:  MPL NG\n"]}