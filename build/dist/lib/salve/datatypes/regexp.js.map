{"version":3,"file":"regexp.js","sourceRoot":"","sources":["../../../../../lib/salve/datatypes/regexp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This is a module that converts XMLSchema regular expressions to\n * plain JavaScript regular expressions.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n// tslint:disable-next-line:import-name no-submodule-imports\nimport base from \"xregexp/lib/addons/unicode-base\";\n// tslint:disable-next-line:import-name no-submodule-imports\nimport blocks from \"xregexp/lib/addons/unicode-blocks\";\n// tslint:disable-next-line:import-name no-submodule-imports\nimport categories from \"xregexp/lib/addons/unicode-categories\";\n// tslint:disable-next-line:import-name no-submodule-imports\nimport XRegExp from \"xregexp/lib/xregexp\";\n\nimport { fixPrototype } from \"../tools\";\nimport { xmlLetter, xmlNameChar } from \"./xmlcharacters\";\n\nbase(XRegExp);\nblocks(XRegExp);\ncategories(XRegExp);\n\n//\n// Terminology:\n//\n// - Character class: a square bracket construct in a regexp.\n//\n// - Positive character class: [...] without a leading caret.\n//\n// - Negative character class: [^...].\n//\n// - Positive match: a single character or range that a character must\n//   match. (Negative character classes also contain positive\n//   matches. In [^abc], \"a\", \"b\" and \"c\" are positive matches. The\n//   character classe is negative but the individual characters are\n//   positive.) The only thing this excludes are multi-char escapes\n//   that match negatively like \\S and \\D.\n//\n// - Positive version of a multi-char escape: defined only for\n//   multi-char escapes that expand to a negative character class; the\n//   same character class but with the negating caret removed. So the\n//   positive version of \\S is \\s, etc.\n//\n// The main transformation performed by this code is to deal with XML\n// Schema regexp's multi character classes that have no class\n// equivalent in JavaScript.\n//\n// Some simple identities:\n//\n// - [xy]  <-> (?:[x]|[y])\n// - [^xy] <-> (?:(?![y])[^x])\n// - (?![^x]) <-> (?=[x])\n//\n// Positive multi-char escape in a positive character class:\n//\n// - [x\\s] -> (?:[x]|[ \\t\\r\\n]) -> [x \\t\\r\\n]\n//\n// Just expand the character class to its constituents.\n//\n// Negative multi-char escape in a positive character class:\n//\n// - [x\\S] -> (?:[x]|[^ \\t\\r\\n])\n//\n// - [x\\S\\D] -> (?:[x\\D]|[^ \\t\\r\\n])\n//           -> (?:[x]|[^\\p{Nd}]|[^ \\t\\r\\n])\n//\n// So we output the positive matches in the class in one positive\n// character class, and ``or`` it with one negative character class\n// per negative multi-char escape.\n//\n// Positive multi-char escape in negative character class:\n//\n// - [^x\\s] -> (?:(?![ \\t\\r\\n])[^x])\n//          -> [^x \\t\\r\\n]\n//\n// Just expand the multi-char escape to its constituents.\n//\n// Negative multi-char escape in negative character class:\n//\n// - [^x\\S] -> (?:(?![^ \\t\\r\\n])[^x])\n//          -> (?:(?=[ \\t\\r\\n])[^x])\n//\n// - [^x\\S\\D] -> (?:(?![\\S\\D])[^x])\n//            -> (?:(?![\\S]|[\\D])[^x])\n//            -> (?:(?=[ \\t\\r\\n\\p{Nd}])[^x])\n//\n// So we output the positive matches in the class in one negative\n// character class, and put a positive lookahead in front with a\n// positive character class that matches the positive version of the\n// negative multi-char escapes.\n//\n// Subtractions:\n//\n// -  [abcd-[bc]] -> (?:(?![bc])[abcd])\n// -  [ad-[bc]]   -> (?:(?![bc])[ad])\n// -  [abcd-[bc-[c]] -> (?:(?![bc-[c]])[abcd])\n//                   -> (?:(?!(?![c])[bc])[abcd])\n// -  [abcd-[^a]] -> (?:(?![^a])[abcd])\n\n// We use the name ``Salve`` to help avoid potential clashes. ``ParsingError``\n// seems too risky.\nexport class SalveParsingError extends Error {\n  constructor(msg: string) {\n    super(msg);\n    fixPrototype(this, SalveParsingError);\n  }\n}\n\ninterface Construct {\n  kind: string;\n  output: string;\n}\n\ninterface Root extends Construct {\n  kind: \"root\";\n  output: string;\n}\n\ninterface Group extends Construct {\n  kind: \"group\";\n  output: string;\n  negative: boolean;\n  // We capture the negative multi-char escapes. Only the negative escapes\n  // require special treatment.\n  capturedMultiChar: string[];\n  subtraction: boolean;\n  toSubtract: string;\n}\n\nfunction isGroup(x: Construct): x is Group {\n  return x.kind === \"group\";\n}\n\nconst multiCharEscapesInGroup: Record<string, string> = {\n  s: \" \\\\t\\\\n\\\\r\",\n  S: \"^ \\\\t\\\\n\\\\r\",\n  i: `${xmlLetter}_:`,\n  I: `^${xmlLetter}_:`,\n  c: xmlNameChar,\n  C: `^${xmlNameChar}`,\n  d: \"\\\\p{Nd}\",\n  D: \"^\\\\p{Nd}\",\n  w: \"^\\\\p{P}\\\\p{Z}\\\\p{C}\",\n  W: \"\\\\p{P}\\\\p{Z}\\\\p{C}\",\n};\n\nconst multiCharEscapes: Record<string, string> = Object.create(null);\nfor (const k of Object.keys(multiCharEscapesInGroup)) {\n  multiCharEscapes[k] = `[${multiCharEscapesInGroup[k]}]`;\n}\n\nexport function parse(input: string, outputType: \"string\"): string;\nexport function parse(input: string, outputType?: \"re\"): RegExp;\nexport function parse(input: string,\n                      outputType: \"re\" | \"string\" = \"re\"): RegExp | string {\n  const converted = convertString(input);\n\n  return outputType === \"re\" ?\n    new (/\\\\p/i.test(converted) ? XRegExp : RegExp)(converted) :\n    converted;\n}\n\n// tslint:disable-next-line:max-func-body-length\nfunction convertString(input: string): string {\n  const root: Root = {\n    kind: \"root\",\n    output: \"\",\n  };\n\n  const stack: (Root | Group)[] = [root];\n  for (let i = 0; i < input.length; ++i) {\n    let top = stack[stack.length - 1];\n    const c = input[i];\n    switch (c) {\n      case \"(\":\n        top.output += \"(?:\";\n        break;\n      case \"[\": {\n        const negative = input[i + 1] === \"^\";\n        stack.push({\n          kind: \"group\",\n          output: negative ? \"[^\" : \"[\",\n          negative,\n          capturedMultiChar: [],\n          subtraction: false,\n          toSubtract: \"\",\n        });\n\n        if (negative) {\n          i++;\n        }\n        break;\n      }\n      case \"]\": {\n        if (isGroup(top)) {\n          const group = top;\n          stack.pop();\n          top = stack[stack.length - 1];\n          const { capturedMultiChar, negative } = group;\n          const plain = `${group.output}]`;\n          const toSubtract = group.toSubtract !== \"\" ?\n            `(?!${group.toSubtract})` : \"\";\n          if (capturedMultiChar.length !== 0) {\n            let prefix = \"\";\n            if (negative) {\n              prefix = \"(?=[\";\n              for (const multiChar of capturedMultiChar) {\n                prefix += multiCharEscapesInGroup[multiChar].slice(1);\n              }\n              prefix += \"])\";\n            }\n            else {\n              for (const multiChar of capturedMultiChar) {\n                prefix += `[${multiCharEscapesInGroup[multiChar]}]|`;\n              }\n            }\n            const combined = `(?:${toSubtract}${prefix}${plain})`;\n            if (isGroup(top) && top.subtraction) {\n              top.toSubtract = combined;\n            }\n            else {\n              top.output += combined;\n            }\n          }\n          else {\n            const combined = toSubtract !== \"\" ?\n              `(?:${toSubtract}${plain})` : plain;\n            if (isGroup(top) && top.subtraction) {\n              top.toSubtract = combined;\n            }\n            else {\n              top.output += combined;\n            }\n          }\n        }\n        break;\n      }\n      case \"-\":\n        if (isGroup(top) && input[i + 1] === \"[\") {\n          top.subtraction = true;\n        }\n        else {\n          top.output += c;\n        }\n        break;\n      case \"\\\\\": {\n        const next = input[i + 1];\n        if (\"sSiIcCdDwW\".includes(next)) {\n          i++;\n          if (isGroup(top)) {\n            const repl = multiCharEscapesInGroup[next];\n            if (repl[0] === \"^\") {\n              top.capturedMultiChar.push(next);\n            }\n            else {\n              top.output += repl;\n            }\n          }\n          else {\n            top.output += multiCharEscapes[next];\n          }\n        }\n        else {\n          top.output += c;\n        }\n        break;\n      }\n      default:\n        top.output += c;\n    }\n  }\n\n  return `^${root.output}$`;\n}\n"]}