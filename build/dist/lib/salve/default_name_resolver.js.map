{"version":3,"file":"default_name_resolver.js","sourceRoot":"","sources":["../../../../lib/salve/default_name_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Implements a name resolver for handling namespace changes in XML.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { EName } from \"./ename\";\nimport { NameResolver, XML1_NAMESPACE,\n         XMLNS_NAMESPACE } from \"./name_resolver\";\n\n/**\n * A resolution context.\n */\ninterface Context {\n  /**\n   * A mapping from namespace prefix to namespace uri.\n   */\n  readonly forward: Map<string, string>;\n\n  /**\n   * A mapping from namespace uri to namespace prefixes. It is \"prefixes\" in the\n   * plural because multiple prefixes may exist for the same uri.\n   */\n  readonly backwards: Map<string, string[]>;\n}\n\n/**\n * A name resolver for handling namespace changes in XML. This name\n * resolver maintains mappings from namespace prefix to namespace URI.\n */\nexport class DefaultNameResolver implements NameResolver {\n  private readonly _contextStack: Context[];\n\n  constructor(other?: DefaultNameResolver) {\n    if (other !== undefined) {\n      this._contextStack = other._contextStack.slice();\n    }\n    else {\n      // Both namespaces defined at:\n      // http://www.w3.org/TR/REC-xml-names/#ns-decl\n      // Skip definePrefix for these initial values.\n      this._contextStack = [{\n        forward: new Map([[\"xml\", XML1_NAMESPACE],\n                          [\"xmlns\", XMLNS_NAMESPACE]]),\n        backwards: new Map([[XML1_NAMESPACE, [\"xml\"]],\n                            [XMLNS_NAMESPACE, [\"xmlns\"]]]),\n      }];\n\n    }\n  }\n\n  /**\n   * Makes a deep copy.\n   *\n   * @returns A deep copy of the resolver.\n   */\n  clone(): this {\n    return new DefaultNameResolver(this) as this;\n  }\n\n  /**\n   * Defines a (prefix, URI) mapping.\n   *\n   * @param prefix The namespace prefix to associate with the URI.\n   *\n   * @param uri The namespace URI associated with the prefix.\n   */\n  definePrefix(prefix: string, uri: string): void {\n    // http://www.w3.org/TR/REC-xml-names/#ns-decl\n    if (prefix === \"xmlns\") {\n      throw new Error(\"trying to define 'xmlns' but the XML Namespaces \" +\n                      \"standard stipulates that 'xmlns' cannot be \" +\n                      \"declared (= \\\"defined\\\")\");\n    }\n\n    if (prefix === \"xml\" && uri !== XML1_NAMESPACE) {\n      throw new Error(\"trying to define 'xml' to an incorrect URI\");\n    }\n\n    const top = this._contextStack[this._contextStack.length - 1];\n    top.forward.set(prefix, uri);\n\n    let prefixes = top.backwards.get(uri);\n    if (prefixes === undefined) {\n      prefixes = [prefix];\n      top.backwards.set(uri, prefixes);\n    }\n    // This ensure that the default namespace is given priority when\n    // unresolving names.\n    else if (prefix === \"\") {\n      prefixes.unshift(\"\");\n    }\n    else {\n      prefixes.push(prefix);\n    }\n  }\n\n  /**\n   * This method is called to indicate the start of a new context.  Contexts\n   * enable this class to support namespace redeclarations. In XML, each start\n   * tag can potentially redefine a prefix that was already defined by an\n   * ancestor. When using this class, such redefinition must appear in a new\n   * context, otherwise it would merely overwrite the old definition.\n   *\n   * See also [[enterContextWithMapping]], which is preferable if you already\n   * know the bindings you need to initialize the context with.\n   *\n   * At creation, a [[NameResolver]] has a default context already\n   * created. There is no need to create it and it is not possible to leave it.\n   */\n  enterContext(): void {\n    this._contextStack.push({\n      forward: new Map(),\n      backwards: new Map(),\n    });\n  }\n\n  /**\n   * Enter a new context, and immediately populate it with bindings. If you\n   * already have a binding map, then using this method is preferable to using\n   * [[enterContext]] because it is faster than doing [[enterContext]] followed\n   * by a series of calls to [[definePrefix]].\n   *\n   * @param mapping The mapping with which to initialize the context.\n   */\n  enterContextWithMapping(mapping: Readonly<Record<string, string>>): void {\n    // http://www.w3.org/TR/REC-xml-names/#ns-decl\n    if (mapping.xmlns !== undefined) {\n      throw new Error(\"trying to define 'xmlns' but the XML Namespaces \" +\n                      \"standard stipulates that 'xmlns' cannot be \" +\n                      \"declared (= \\\"defined\\\")\");\n    }\n\n    const xmlMapping = mapping.xml;\n    if (xmlMapping !== undefined && xmlMapping !== XML1_NAMESPACE) {\n      throw new Error(\"trying to define 'xml' to an incorrect URI\");\n    }\n\n    const forward = new Map();\n    const backwards = new Map();\n    for (const prefix of Object.keys(mapping)) {\n      const uri = mapping[prefix];\n      forward.set(prefix, uri);\n\n      let prefixes = backwards.get(uri);\n      if (prefixes === undefined) {\n        prefixes = [prefix];\n        backwards.set(uri, prefixes);\n      }\n      // This ensure that the default namespace is given priority when\n      // unresolving names.\n      else if (prefix === \"\") {\n        prefixes.unshift(\"\");\n      }\n      else {\n        prefixes.push(prefix);\n      }\n    }\n\n    this._contextStack.push({ forward, backwards });\n  }\n\n  /**\n   * This method is called to indicate the end of a context. Whatever context\n   * was in effect when the current context ends becomes effective.\n   *\n   * @throws {Error} If this method is called when there is no context created\n   * by [[enterContext]].\n   */\n  leaveContext(): void {\n    if (this._contextStack.length > 1) {\n      this._contextStack.pop();\n    }\n    else {\n      throw new Error(\"trying to leave the default context\");\n    }\n  }\n\n  /**\n   * Resolves a qualified name to an expanded name. A qualified name is an XML\n   * name optionally prefixed by a namespace prefix. For instance, in ``<html\n   * xml:lang=\"en\">``, \"html\" is a name without a prefix, and \"xml:lang\" is a\n   * name with the \"xml\" prefix. An expanded name is a (URI, name) pair.\n   *\n   * @param name The name to resolve.\n   *\n   * @param attribute Whether this name appears as an attribute.\n   *\n   * @throws {Error} If the name is malformed. For instance, a name with two\n   * colons would be malformed.\n   *\n   * @returns The expanded name, or ``undefined`` if the name cannot be\n   * resolved.\n   */\n  resolveName(name: string, attribute: boolean = false): EName | undefined {\n    const colon = name.indexOf(\":\");\n\n    let prefix: string;\n    let local: string;\n    if (colon === -1) {\n      if (attribute) { // Attribute in undefined namespace\n        return new EName(\"\", name);\n      }\n\n      // We are searching for the default namespace currently in effect.\n      prefix = \"\";\n      local = name;\n    }\n    else {\n      prefix = name.substr(0, colon);\n      local = name.substr(colon + 1);\n      if (local.includes(\":\")) {\n        throw new Error(\"invalid name passed to resolveName\");\n      }\n    }\n\n    // Search through the contexts.\n    for (let ix = this._contextStack.length - 1; ix >= 0; --ix) {\n      const context = this._contextStack[ix];\n      const uri = context.forward.get(prefix);\n      if (uri !== undefined) {\n        return new EName(uri, local);\n      }\n    }\n\n    // If we get here uri is necessarily undefined.\n    return (prefix === \"\") ? new EName(\"\", local) : undefined;\n  }\n\n  /**\n   * Unresolves an expanded name to a qualified name. An expanded name is a\n   * (URI, name) pair. Note that if we execute:\n   *\n   * <pre>\n   *   var nameResolver = new NameResolver();\n   *   var ename = nameResolver.resolveName(qname);\n   *   var qname2 = nameResolver.unresolveName(ename.ns, ename.name);\n   * </pre>\n   *\n   * then ``qname === qname2`` is not necessarily true. This would happen if two\n   * prefixes map to the same URI. In such case the prefix provided in the\n   * return value is arbitrarily chosen.\n   *\n   * @param uri The URI part of the expanded name. An empty string is\n   * valid, and basically means \"no namespace\". This occurs for unprefixed\n   * attributes but could also happen if the default namespace is undeclared.\n   *\n   * @param  name The name part.\n   *\n   * @returns The qualified name that corresponds to the expanded name, or\n   * ``undefined`` if it cannot be resolved.\n   */\n  unresolveName(uri: string, name: string): string | undefined {\n    if (uri === \"\") {\n      return name;\n    }\n\n    // Search through the contexts.\n    let prefixes: string[] | undefined;\n    for (let cIx = this._contextStack.length - 1;\n         (prefixes === undefined) && (cIx >= 0); --cIx) {\n      prefixes = this._contextStack[cIx].backwards.get(uri);\n    }\n\n    if (prefixes === undefined) {\n      return undefined;\n    }\n\n    const pre = prefixes[0];\n\n    return (pre !== \"\") ? `${pre}:${name}` : name;\n  }\n\n  /**\n   * Returns a prefix that, in the current context, is mapped to the URI\n   * specified. Note that this function will return the first prefix that\n   * satisfies the requirement, starting from the innermost context.\n   *\n   * @param uri A URI for which to get a prefix.\n   *\n   * @returns A prefix that maps to this URI. Undefined if there is no prefix\n   * available.\n   */\n  prefixFromURI(uri: string): string | undefined {\n    let prefixes: string[] | undefined;\n    for (let cIx = this._contextStack.length - 1;\n         (prefixes === undefined) && (cIx >= 0); --cIx) {\n      prefixes = this._contextStack[cIx].backwards.get(uri);\n    }\n\n    if (prefixes === undefined) {\n      return undefined;\n    }\n\n    return prefixes[0];\n  }\n}\n\n//  LocalWords:  unprefixed nameResolver pre definePrefix Unresolves qname vm\n//  LocalWords:  redeclarations newID ename lang html NameResolver Mangalam uri\n//  LocalWords:  xmlns URI Dubeau resolveName xml MPL unresolving namespace\n"]}