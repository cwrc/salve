{"version":3,"file":"step10.js","sourceRoot":"","sources":["../../../../../../lib/salve/conversion/simplifier/step10.ts"],"names":[],"mappings":";;;AAAA;;;;;GAKG;AACH,sCAA+C;AAC/C,4DAA6D;AAC7D,iCACuC;AAEvC,wEAAwE;AACxE,2EAA2E;AAC3E,oCAAoC;AAEpC,SAAS,UAAU,CAAC,EAAW;IAC7B,IAAI,EAAE,CAAC,KAAK,KAAK,QAAQ,EAAE;QACzB,4CAA4C;QAC5C,iDAAiD;QACjD,QAAQ,EAAE,CAAC,MAAO,CAAC,KAAK,EAAE;YACxB,KAAK,SAAS;gBACZ,IAAI,iCAA0B,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC1D,MAAM,IAAI,yCAAqB,CAC7B,gDAAgD,CAAC,CAAC;iBACrD;gBACD,MAAM;YACR,KAAK,QAAQ,CAAC,CAAC;gBACb,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,GAC1C,sCAA+B,CAAC,EAAE,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAC7D,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;oBACzB,MAAM,IAAI,yCAAqB,CAC7B,+CAA+C,CAAC,CAAC;iBACpD;gBAED,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;oBACxB,MAAM,IAAI,yCAAqB,CAC7B,8CAA8C,CAAC,CAAC;iBACnD;gBACD,MAAM;aACP;YACD,QAAQ;SACT;KACF;IAED,KAAK,MAAM,KAAK,IAAI,EAAE,CAAC,QAAQ,EAAE;QAC/B,IAAI,CAAC,kBAAS,CAAC,KAAK,CAAC,EAAE;YACrB,SAAS;SACV;QAED,UAAU,CAAC,KAAK,CAAC,CAAC;KACnB;AACH,CAAC;AAED,gDAAgD;AAChD,SAAS,IAAI,CAAC,KAAc,EAAE,EAAW;IACvC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC;IAE/B,QAAQ,KAAK,EAAE;QACb,KAAK,QAAQ,CAAC;QACd,KAAK,OAAO,CAAC;QACb,KAAK,YAAY;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACzB,MAAM,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAY,CAAC;gBAC3C,IAAI,EAAE,CAAC,MAAM,KAAK,SAAS,EAAE;oBAC3B,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,EAAE,WAAW,CAAC,CAAC;iBAC7C;qBACI;oBACH,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,oCAAoC;oBACzD,qEAAqE;oBACrE,mBAAmB;oBACnB,MAAM,KAAK,GAAG,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;oBACvC,IAAI,KAAK,KAAK,SAAS,EAAE;wBACvB,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;qBAC7B;iBACF;gBAED,OAAO,WAAW,CAAC;aACpB;iBACI;gBACH,OAAO,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC1B,EAAE,CAAC,YAAY,CAAC,gBAAO,CAAC,WAAW,CAAC,KAAK,EACL,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBAClE;aACF;YACD,MAAM;QACR,KAAK,SAAS;YACZ,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,EAAE,CAAC,WAAW,CAAC,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACjE;YAED,IAAI,KAAK,EAAE;gBACT,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAY,CAAC,CAAC;aACpC;YACD,MAAM;QACR,KAAK,WAAW;YACd,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACzB,EAAE,CAAC,WAAW,CAAC,gBAAO,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;aACjD;YAED,IAAI,KAAK,EAAE;gBACT,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAY,CAAC,CAAC;gBACnC,KAAK,MAAM,QAAQ,IAAI,qBAAc,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE;oBACxD,QAAQ,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;wBACnC,KAAK,EAAE;4BACL,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;gCAC7B,MAAM,IAAI,yCAAqB,CAC7B,wDAAwD,CAAC,CAAC;6BAC7D;4BACD,MAAM;wBACN,0CAA0C;wBAC5C,KAAK,8BAA8B;4BACjC,MAAM,IAAI,yCAAqB,CAC7B,2DAA2D,CAAC,CAAC;wBACjE,QAAQ;qBACT;iBACF;aACF;YACD,MAAM;QACR,KAAK,QAAQ,CAAC;QACd,KAAK,WAAW,CAAC;QACjB,KAAK,MAAM;YACT,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,KAAK,GAAG,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;gBAC/C,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACvB,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACvB;YACD,MAAM;QACR,KAAK,YAAY,CAAC,CAAC;YACjB,EAAE,CAAC,KAAK,GAAG,QAAQ,CAAC;YACpB,MAAM,SAAS,GAAG,gBAAO,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACvD,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,KAAK,GAAG,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;gBAC/C,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACvB,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aAC9B;iBACI;gBACH,SAAS,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;aAC5B;YACD,EAAE,CAAC,cAAc,CAAC,CAAC,SAAS,EAAE,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;YACjE,MAAM;SACP;QACD,KAAK,UAAU;YACb,EAAE,CAAC,KAAK,GAAG,QAAQ,CAAC;YACpB,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,KAAK,GAAG,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;gBAC/C,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACvB,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACvB;YACD,EAAE,CAAC,WAAW,CAAC,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;YACjD,MAAM;QACR,KAAK,OAAO;YACV,EAAE,CAAC,KAAK,GAAG,YAAY,CAAC;YACxB,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,KAAK,GAAG,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;gBAC/C,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACvB,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACvB;YACD,EAAE,CAAC,WAAW,CAAC,gBAAO,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;YAChD,MAAM;QACR,KAAK,QAAQ;YACX,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvB,MAAM,MAAM,GAAG,gBAAO,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;gBACjD,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACxB,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;aACxB;YACD,MAAM;QACR,QAAQ;KACT;IAED,yCAAyC;IACzC,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;QAC3C,MAAM,KAAK,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;QAC3B,IAAI,CAAC,kBAAS,CAAC,KAAK,CAAC,EAAE;YACrB,SAAS;SACV;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAClC,OAAO,QAAQ,KAAK,IAAI,EAAE;YACxB,QAAQ,GAAG,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;SAClC;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyCG;AACH,SAAgB,MAAM,CAAC,EAAW,EAAE,KAAc;IAChD,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC/B,OAAO,QAAQ,KAAK,IAAI,EAAE;QACxB,EAAE,GAAG,QAAQ,CAAC;QACd,QAAQ,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;KAC5B;IAED,OAAO,EAAE,CAAC;AACZ,CAAC;AARD,wBAQC","sourcesContent":["/**\n * Simplification step 10.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element, isElement } from \"../parser\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport { findDescendantsByLocalName, findMultiDescendantsByLocalName,\n         findMultiNames} from \"./util\";\n\n// We do not do the checks on ``data`` and ``value`` here. They are done\n// later. The upshot is that fragments of the schema that may be removed in\n// later steps are not checked here.\n\nfunction checkNames(el: Element): void {\n  if (el.local === \"except\") {\n    // parent cannot be undefined at this point.\n    // tslint:disable-next-line:no-non-null-assertion\n    switch (el.parent!.local) {\n      case \"anyName\":\n        if (findDescendantsByLocalName(el, \"anyName\").length !== 0) {\n          throw new SchemaValidationError(\n            \"an except in anyName has an anyName descendant\");\n        }\n        break;\n      case \"nsName\": {\n        const { anyName: anyNames, nsName: nsNames } =\n          findMultiDescendantsByLocalName(el, [\"anyName\", \"nsName\"]);\n        if (anyNames.length !== 0) {\n          throw new SchemaValidationError(\n            \"an except in nsName has an anyName descendant\");\n        }\n\n        if (nsNames.length !== 0) {\n          throw new SchemaValidationError(\n            \"an except in nsName has an nsName descendant\");\n        }\n        break;\n      }\n      default:\n    }\n  }\n\n  for (const child of el.children) {\n    if (!isElement(child)) {\n      continue;\n    }\n\n    checkNames(child);\n  }\n}\n\n// tslint:disable-next-line:max-func-body-length\nfunction walk(check: boolean, el: Element): Element | null {\n  const { local, children } = el;\n\n  switch (local) {\n    case \"choice\":\n    case \"group\":\n    case \"interleave\":\n      if (children.length === 1) {\n        const replaceWith = children[0] as Element;\n        if (el.parent !== undefined) {\n          el.parent.replaceChildWith(el, replaceWith);\n        }\n        else {\n          el.removeChildAt(0); // This removes replaceWith from el.\n          // By this stage in the process, this is the only attribute that need\n          // be carried over.\n          const xmlns = el.getAttribute(\"xmlns\");\n          if (xmlns !== undefined) {\n            replaceWith.setXMLNS(xmlns);\n          }\n        }\n\n        return replaceWith;\n      }\n      else {\n        while (children.length > 2) {\n          el.prependChild(Element.makeElement(local,\n                                              [children[0], children[1]]));\n        }\n      }\n      break;\n    case \"element\":\n      if (children.length > 2) {\n        el.appendChild(Element.makeElement(\"group\", children.slice(1)));\n      }\n\n      if (check) {\n        checkNames(children[0] as Element);\n      }\n      break;\n    case \"attribute\":\n      if (children.length === 1) {\n        el.appendChild(Element.makeElement(\"text\", []));\n      }\n\n      if (check) {\n        checkNames(children[0] as Element);\n        for (const attrName of findMultiNames(el, [\"name\"]).name) {\n          switch (attrName.getAttribute(\"ns\")) {\n            case \"\":\n              if (attrName.text === \"xmlns\") {\n                throw new SchemaValidationError(\n                  \"found attribute with name xmlns outside all namespaces\");\n              }\n              break;\n              // tslint:disable-next-line:no-http-string\n            case \"http://www.w3.org/2000/xmlns\":\n              throw new SchemaValidationError(\n                \"found attribute in namespace http://www.w3.org/2000/xmlns\");\n            default:\n          }\n        }\n      }\n      break;\n    case \"define\":\n    case \"oneOrMore\":\n    case \"list\":\n      if (children.length > 1) {\n        const group = Element.makeElement(\"group\", []);\n        group.grabChildren(el);\n        el.appendChild(group);\n      }\n      break;\n    case \"zeroOrMore\": {\n      el.local = \"choice\";\n      const oneOrMore = Element.makeElement(\"oneOrMore\", []);\n      if (children.length > 1) {\n        const group = Element.makeElement(\"group\", []);\n        group.grabChildren(el);\n        oneOrMore.appendChild(group);\n      }\n      else {\n        oneOrMore.grabChildren(el);\n      }\n      el.appendChildren([oneOrMore, Element.makeElement(\"empty\", [])]);\n      break;\n    }\n    case \"optional\":\n      el.local = \"choice\";\n      if (children.length > 1) {\n        const group = Element.makeElement(\"group\", []);\n        group.grabChildren(el);\n        el.appendChild(group);\n      }\n      el.appendChild(Element.makeElement(\"empty\", []));\n      break;\n    case \"mixed\":\n      el.local = \"interleave\";\n      if (children.length > 1) {\n        const group = Element.makeElement(\"group\", []);\n        group.grabChildren(el);\n        el.appendChild(group);\n      }\n      el.appendChild(Element.makeElement(\"text\", []));\n      break;\n    case \"except\":\n      if (children.length > 1) {\n        const choice = Element.makeElement(\"choice\", []);\n        choice.grabChildren(el);\n        el.appendChild(choice);\n      }\n      break;\n    default:\n  }\n\n  // tslint:disable-next-line:prefer-for-of\n  for (let ix = 0; ix < children.length; ++ix) {\n    const child = children[ix];\n    if (!isElement(child)) {\n      continue;\n    }\n\n    let replaced = walk(check, child);\n    while (replaced !== null) {\n      replaced = walk(check, replaced);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Implements steps 10 to 13 of the XSL pipeline. Namely:\n *\n * - ``define``, ``oneOrMore``, ``zeroOrMore``, ``optional``, ``list`` and\n *   ``mixed`` elements with more than one child have their children wrapped in\n *   a ``group`` element.\n *\n * - ``element`` elements with more than two children have their children\n *   wrapped in a ``group`` element. (This means more than one child in addition\n *   to the name class which is the 1sts element of ``element`` at this point.)\n *\n * - ``except`` elements with more than one child have their children wrapped in\n *   a ``group`` element.\n *\n * - ``attribute`` elements with only one child (only a ``name`` element) get a\n *   ``<text/>`` child.\n *\n * - ``choice``, ``group`` and ``interleave`` elements with only one child are\n *   replaced by their single child.\n *\n * - ``choice``, ``group`` and ``interleave`` elements with more than 2 children\n *   have their first 2 children wrapped in an element of the same name, and\n *   this is repeated until the top level element contains only two\n *   children. (This transformation applies to elements that were part of the\n *   input and those elements created by the transformations above.)\n *\n * - ``mixed`` elements are converted to ``interleave`` elements containing the\n *    single child of ``mixed``, and ``<text/>``.\n *\n * - ``optional`` elements are converted to ``choice`` elements containing the\n *   single child of ``optional``, and ``<empty/>``.\n *\n * - ``zeroOrMore`` elements are converted to ``choice`` elements. The single\n *   child of the original ``zeroOrMore`` element is wrapped in a ``oneOrMore``\n *   element, and ``<empty/>`` is added to the ``choice`` element.\n *\n * @param el The tree to process. It is modified in-place.\n *\n * @param check Whether to perform constraint checks.\n *\n * @returns The new root of the tree.\n */\nexport function step10(el: Element, check: boolean): Element {\n  let replaced = walk(check, el);\n  while (replaced !== null) {\n    el = replaced;\n    replaced = walk(check, el);\n  }\n\n  return el;\n}\n"]}