{"version":3,"file":"step18.js","sourceRoot":"","sources":["../../../../../../lib/salve/conversion/simplifier/step18.ts"],"names":[],"mappings":";;;AAAA;;;;;GAKG;AACH,sCAAoC;AAEpC,gDAAgD;AAChD,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO;IAC7C,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC;AAE7D,SAAS,IAAI,CAAC,EAAW,EAAE,EAAU;IACnC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC;IAE/B,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC5C,OAAO;KACR;IAED,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,QAA8B,CAAC;IACrD,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IACf,IAAI,MAAM,KAAK,SAAS,EAAE;QACxB,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;KACjB;IAED,iCAAiC;IACjC,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,QAA8B,CAAC,CAAC;IAEnD,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,KAAK,OAAO,CAAC;IAC3C,MAAM,WAAW,GAAG,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,KAAK,KAAK,OAAO,CAAC;IAErE,IAAI,CAAC,CAAC,UAAU,IAAI,WAAW,CAAC,EAAE;QAChC,OAAO;KACR;IAED,QAAQ,KAAK,EAAE;QACb,KAAK,QAAQ;YACX,IAAI,WAAW,EAAE;gBACf,IAAI,CAAC,UAAU,EAAE;oBACf,8DAA8D;oBAC9D,WAAW;oBACX,QAAQ,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;oBACrB,QAAQ,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;iBACrB;qBACI;oBACH,2DAA2D;oBAC3D,EAAE,CAAC,MAAO,CAAC,cAAc,CAAC,EAAE,EAAE,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;iBACjE;aACF;YACD,MAAM;QACR,KAAK,OAAO,CAAC;QACb,KAAK,YAAY;YACf,EAAE,CAAC,MAAO,CAAC,cAAc,CAAC,EAAE,EACF,UAAU,IAAI,WAAW,CAAC,CAAC;gBAC3B,yCAAyC;gBACzC,mCAAmC;gBACnC,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;gBAClC,8CAA8C;gBAC9C,8CAA8C;gBAC9C,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACzD,MAAM;QACR,KAAK,WAAW;YACd,4DAA4D;YAC5D,EAAE,CAAC,MAAO,CAAC,cAAc,CAAC,EAAE,EAAE,gBAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;YAChE,MAAM;QACR,QAAQ;KACT;AACH,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,SAAgB,MAAM,CAAC,IAAa;IAClC,8EAA8E;IAC9E,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;QACjC,IAAI,CAAC,KAAgB,EAAE,EAAE,EAAE,CAAC,CAAC;KAC9B;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AARD,wBAQC;AAED,8BAA8B","sourcesContent":["/**\n * Simplification step 18.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"../parser\";\n\n// These are elements that cannot contain empty.\nconst skip = new Set([\"name\", \"anyName\", \"nsName\", \"param\", \"empty\",\n                      \"text\", \"value\", \"notAllowed\", \"ref\"]);\n\nfunction walk(el: Element, ix: number): void {\n  const { local, children } = el;\n\n  if (children.length === 0 || skip.has(local)) {\n    return;\n  }\n\n  let [first, second] = children as [Element, Element];\n  walk(first, 0);\n  if (second !== undefined) {\n    walk(second, 1);\n  }\n\n  // The children may have changed.\n  ([first, second] = children as [Element, Element]);\n\n  const firstEmpty = first.local === \"empty\";\n  const secondEmpty = second !== undefined && second.local === \"empty\";\n\n  if (!(firstEmpty || secondEmpty)) {\n    return;\n  }\n\n  switch (local) {\n    case \"choice\":\n      if (secondEmpty) {\n        if (!firstEmpty) {\n          // If a choice has empty in the 2nd position, the children are\n          // swapped.\n          children[0] = second;\n          children[1] = first;\n        }\n        else {\n          // A choice with two empty elements is replaced with empty.\n          el.parent!.replaceChildAt(ix, Element.makeElement(\"empty\", []));\n        }\n      }\n      break;\n    case \"group\":\n    case \"interleave\":\n      el.parent!.replaceChildAt(ix,\n                                firstEmpty && secondEmpty ?\n                                // A group (or interleave) with two empty\n                                // elements is replaced with empty.\n                                Element.makeElement(\"empty\", []) :\n                                // A group (or interleave) with only one empty\n                                // element is replaced with the non-empty one.\n                                (firstEmpty ? second : first));\n      break;\n    case \"oneOrMore\":\n      // A oneOrMore with an empty element is replaced with empty.\n      el.parent!.replaceChildAt(ix, Element.makeElement(\"empty\", []));\n      break;\n    default:\n  }\n}\n\n/**\n * Implements step 18 of the XSL pipeline. Namely:\n *\n * - All ``group``, ``interleave`` and ``choice`` elements with two ``empty``\n *   children are replaced with ``empty``.\n *\n * - All ``group`` and ``interleave`` elements with one ``empty`` child\n *   are transformed into their other child.\n *\n * - All ``choice`` elements with ``empty`` as the second child have their\n *   children swapped.\n *\n * - All ``oneOrMore`` elements with an ``empty`` child are replaced with\n *   ``empty``.\n *\n * These transformations are repeated until they no longer modify the tree. (The\n * way we apply the transformations obviates the need to repeat them.)\n *\n * Note that none of the transformations above remove ``ref`` elements from the\n * schema. So it is not necessary to check for unreferenced ``define``\n * elements. (To ascertain that this is the case, you need to take into account\n * the previous transformations. For instance, ``oneOrMore`` by this stage has\n * only one possible child so replacing ``oneOrMore`` with ``empty`` if it has\n * an ``empty`` child **cannot** remove a ``ref`` element from the tree. Similar\n * reasoning applies to the other transformations.)\n *\n * @param tree The tree to process. It is modified in-place.\n *\n * @returns The new root of the tree.\n */\nexport function step18(tree: Element): Element {\n  // The top element is necessarily <grammar>, and it has only element children.\n  let ix = 0;\n  for (const child of tree.children) {\n    walk(child as Element, ix++);\n  }\n\n  return tree;\n}\n\n//  LocalWords:  XSL oneOrMore\n"]}