{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This module contains classes for a conversion parser.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nimport { SaxesAttribute, SaxesParser, SaxesTag } from \"saxes\";\n\nimport { EName } from \"../ename\";\nimport { ValidationError } from \"../errors\";\nimport { NameResolver, XML1_NAMESPACE,\n         XMLNS_NAMESPACE } from \"../name_resolver\";\nimport { Grammar, GrammarWalker } from \"../patterns\";\nimport { fixPrototype } from \"../tools\";\nimport { ANNOS_URI, RELAXNG_URI, XHTML_URI } from \"./simplifier/util\";\n\nexport type ConcreteNode = Element | Text;\n\nconst emptyNS = Object.create(null);\n\n/**\n * An Element produced by [[BasicParser]].\n *\n * This constructor will insert the created object into the parent automatically\n * if the parent is provided.\n */\nexport class Element {\n  readonly kind: \"element\" = \"element\";\n  /**\n   * The path of the element in its tree.\n   */\n  private _path: string | undefined;\n\n  private _parent: Element | undefined;\n\n  prefix: string;\n\n  local: string;\n\n  uri: string;\n\n  documentation: string | undefined;\n\n  // ns is meant to be immutable.\n  private readonly ns: Record<string, string>;\n\n  attributes: Record<string, SaxesAttribute>;\n\n  /**\n   * @param node The value of the ``node`` created by the SAX parser.\n   *\n   * @param children The children of this element. **These children must not yet\n   * be children of any element.**\n   */\n  constructor(prefix: string,\n              local: string,\n              uri: string,\n              ns: Record<string, string>,\n              attributes: Record<string, SaxesAttribute>,\n              documentation: string | undefined,\n              readonly children: ConcreteNode[]) {\n    this.prefix = prefix;\n    this.local = local;\n    this.uri = uri;\n    // Namespace declarations are immutable.\n    this.ns = ns;\n    this.attributes = attributes;\n    this.documentation = documentation;\n\n    for (const child of children) {\n      if (child.parent !== undefined) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n    }\n  }\n\n  static fromSax(node: SaxesTag, children: ConcreteNode[],\n                 documentation: string = \"\"): Element {\n    return new Element(\n      node.prefix,\n      node.local,\n      node.uri,\n      node.ns,\n      node.attributes as Record<string, SaxesAttribute>,\n      documentation,\n      children);\n  }\n\n  static makeElement(name: string, children: ConcreteNode[],\n                     documentation: string = \"\"): Element {\n    return new Element(\n      \"\",\n      name,\n      \"\",\n      // We always pass the same object as ns. So we save an unnecessary object\n      // creation.\n      emptyNS,\n      Object.create(null),\n      documentation,\n      children);\n  }\n\n  get parent(): Element | undefined {\n    return this._parent;\n  }\n\n  set parent(value: Element | undefined) {\n    this.setParent(value);\n  }\n\n  setParent(value: Element | undefined): void {\n    //\n    // The cost of looking for cycles is noticeable. So we should use this\n    // only when debugging new code.\n    //\n\n    // let scan = value;\n    // while (scan !== undefined) {\n    //   if (scan === this) {\n    //     throw new Error(\"creating reference loop!\");\n    //   }\n\n    //   scan = scan.parent;\n    // }\n\n    this._path = undefined; // This becomes void.\n    this._parent = value;\n  }\n\n  resolve(name: string): string | undefined {\n    if (name === \"xml\") {\n      return XML1_NAMESPACE;\n    }\n\n    if (name === \"xmlns\") {\n      return XMLNS_NAMESPACE;\n    }\n\n    return this._resolve(name);\n  }\n\n  _resolve(name: string): string | undefined {\n    const ret = this.ns[name];\n\n    if (ret !== undefined) {\n      return ret;\n    }\n\n    return (this.parent === undefined) ? undefined : this.parent._resolve(name);\n  }\n\n  get text(): string {\n    // Testing for this special case does payoff.\n    if (this.children.length === 1) {\n      return this.children[0].text;\n    }\n\n    let ret = \"\";\n    for (const child of this.children) {\n      ret += child.text;\n    }\n    return ret;\n  }\n\n  /**\n   * A path describing the location of the element in the XML. Note that this is\n   * meant to be used **only** after the simplification is complete. The value\n   * is computed once and for all as soon as it is accessed.\n   */\n  get path(): string {\n    if (this._path === undefined) {\n      this._path = this.makePath();\n    }\n\n    return this._path;\n  }\n\n  private makePath(): string {\n    let ret =\n      `${(this.parent !== undefined) ? this.parent.path : \"\"}/${this.local}`;\n\n    const name = this.getAttribute(\"name\");\n    if (name !== undefined) {\n      // tslint:disable-next-line:no-string-literal\n      ret += `[@name='${name}']`;\n    }\n    // Name classes are only valid on elements and attributes. So don't go\n    // searching for it on other elements.\n    else if (this.local === \"element\" || this.local === \"attribute\") {\n      // By the time path is used, the name class is the first child.\n      const first = this.children[0];\n      if (isElement(first) && first.local === \"name\") {\n        ret += `[@name='${first.text}']`;\n      }\n    }\n\n    return ret;\n  }\n\n  removeChild(child: ConcreteNode): void {\n    // We purposely don't call removeChildAt, so as to save a call.\n    //\n    // We don't check whether there's an element at [0]. If not, a hard fail is\n    // appropriate. It shouldn't happen.\n    this.children.splice(this.indexOfChild(child), 1)[0].parent = undefined;\n  }\n\n  removeChildAt(i: number): void {\n    // We don't check whether there's an element at [0]. If not, a hard fail is\n    // appropriate. It shouldn't happen.\n    this.children.splice(i, 1)[0].parent = undefined;\n  }\n\n  replaceChildWith(child: ConcreteNode, replacement: ConcreteNode): void {\n    this.replaceChildAt(this.indexOfChild(child), replacement);\n  }\n\n  replaceChildAt(i: number, replacement: ConcreteNode): void {\n    const child = this.children[i];\n\n    // In practice this is not a great optimization.\n    //\n    // if (child === replacement) {\n    //   return;\n    // }\n\n    if (replacement.parent !== undefined) {\n      replacement.parent.removeChild(replacement);\n    }\n\n    this.children[i] = replacement;\n    child.parent = undefined;\n\n    replacement.parent = this;\n  }\n\n  appendChild(child: ConcreteNode): void {\n    // It is faster to use custom code than to rely on insertAt: splice\n    // operations are costly.\n    if (child.parent !== undefined) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.children.push(child);\n  }\n\n  appendChildren(children: ConcreteNode[]): void {\n    // It is faster to use custom code than to rely on insertAt: splice\n    // operations are costly.\n    for (const el of children) {\n      if (el.parent !== undefined) {\n        el.parent.removeChild(el);\n      }\n      el.parent = this;\n    }\n    this.children.push(...children);\n  }\n\n  prependChild(child: ConcreteNode): void {\n    // It is faster to do this than to rely on insertAt: splice operations\n    // are costly.\n    if (child.parent !== undefined) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.children.unshift(child);\n  }\n\n  insertAt(index: number, toInsert: ConcreteNode[]): void {\n    for (const el of toInsert) {\n      if (el.parent !== undefined) {\n        el.parent.removeChild(el);\n      }\n      el.parent = this;\n    }\n    this.children.splice(index, 0, ...toInsert);\n  }\n\n  /**\n   * Gets all the children from another element and append them to this\n   * element. This is a faster operation than done through other means.\n   *\n   * @param src The element form which to get the children.\n   */\n  grabChildren(src: Element): void {\n    const children = src.children.splice(0, src.children.length);\n    this.children.push(...children);\n    for (const child of children) {\n      child.parent = this;\n    }\n  }\n\n  replaceContent(children: ConcreteNode[]): void {\n    const prev = this.children.splice(0, this.children.length, ...children);\n    for (const child of prev) {\n      child.parent = undefined;\n    }\n    for (const child of children) {\n      child.parent = this;\n    }\n  }\n\n  protected indexOfChild(this: ConcreteNode, child: ConcreteNode): number {\n    const parent = child.parent;\n    if (parent !== this) {\n      throw new Error(\"the child is not a child of this\");\n    }\n\n    const index = parent.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"child not among children\");\n    }\n\n    return index;\n  }\n\n  /**\n   * Set an attribute on an element.\n   *\n   * @param name The attribute name.\n   *\n   * @param value The new value of the attribute.\n   */\n  setAttribute(name: string, value: string): void {\n    if (name.includes(\":\")) {\n      throw new Error(\"we don't support namespaces on this function\");\n    }\n\n    this.attributes[name] = {\n      name,\n      prefix: \"\",\n      local: name,\n      uri: \"\",\n      value,\n    };\n  }\n\n  setXMLNS(value: string): void {\n    this.attributes.xmlns = {\n      name: \"xmlns\",\n      prefix: \"\",\n      uri: XMLNS_NAMESPACE,\n      value,\n      local: \"xmlns\",\n    };\n  }\n\n  removeAttribute(name: string): void {\n    delete this.attributes[name];\n  }\n\n  getAttribute(name: string): string | undefined {\n    const attr = this.attributes[name];\n\n    return (attr !== undefined) ? attr.value : undefined;\n  }\n\n  getRawAttributes(): Record<string, SaxesAttribute> {\n    return this.attributes;\n  }\n\n  mustGetAttribute(name: string): string {\n    const attr = this.getAttribute(name);\n    if (attr === undefined) {\n      throw new Error(`no attribute named ${name}`);\n    }\n\n    return attr;\n  }\n\n  clone(): Element {\n    const newAttributes: Record<string, SaxesAttribute> = Object.create(null);\n    const { attributes } = this;\n    const keys = Object.keys(attributes);\n    if (keys.length !== 0) {\n      for (const key of keys) {\n        // We do not use Object.create(null) here because there's no advantage\n        // to it.\n        newAttributes[key] = {...attributes[key]};\n      }\n    }\n\n    // This switch provides a significant improvement.\n    let { children } = this;\n    switch (children.length) {\n      case 0:\n        break;\n      case 1:\n        children = [children[0].clone()];\n        break;\n      case 2:\n        children = [children[0].clone(), children[1].clone()];\n        break;\n      default:\n        // This actually does not happen in the current code.\n        children = children.map(child => child.clone());\n    }\n\n    return new Element(\n      this.prefix,\n      this.local,\n      this.uri,\n      this.ns,\n      newAttributes,\n      this.documentation,\n      children);\n  }\n}\n\nexport class Text {\n  readonly kind: \"text\" = \"text\";\n  parent: Element | undefined;\n\n  /**\n   * @param text The textual value.\n   */\n  constructor(readonly text: string) {\n  }\n\n  clone(): Text {\n    return new Text(this.text);\n  }\n}\n\nexport function isElement(node: ConcreteNode): node is Element {\n  return node.kind === \"element\";\n}\n\nexport function isText(node: ConcreteNode): node is Text {\n  return node.kind === \"text\";\n}\n\nexport interface ValidatorI {\n  onopentag(node: SaxesTag): void;\n  onclosetag(node: SaxesTag): void;\n  ontext(text: string): void;\n  onend(): void;\n}\n\nclass SaxesNameResolver implements NameResolver {\n  constructor(private readonly saxesParser: SaxesParser) {}\n\n  resolveName(name: string,\n              attribute: boolean = false): EName | undefined {\n    const colon = name.indexOf(\":\");\n\n    let prefix: string;\n    let local: string;\n    if (colon === -1) {\n      if (attribute) { // Attribute in undefined namespace\n        return new EName(\"\", name);\n      }\n\n      // We are searching for the default namespace currently in effect.\n      prefix = \"\";\n      local = name;\n    }\n    else {\n      prefix = name.substring(0, colon);\n      local = name.substring(colon + 1);\n      if (local.includes(\":\")) {\n        throw new Error(\"invalid name passed to resolveName\");\n      }\n    }\n\n    const uri = this.saxesParser.resolve(prefix);\n    if (uri !== undefined) {\n      return new EName(uri, local);\n    }\n\n    return (prefix === \"\") ? new EName(\"\", local) : undefined;\n  }\n\n  clone(): this {\n    throw new Error(\"cannot clone a SaxesNameResolver\");\n  }\n}\n\nexport class Validator implements ValidatorI {\n  /** Whether we ran into an error. */\n  readonly errors: ValidationError[] = [];\n\n  /** The walker used for validating. */\n  private readonly walker: GrammarWalker<SaxesNameResolver>;\n\n  constructor(grammar: Grammar, parser: SaxesParser) {\n    this.walker = grammar.newWalker(new SaxesNameResolver(parser));\n  }\n\n  protected fireEvent(name: string, args: string[]): void {\n    const ret = this.walker.fireEvent(name, args);\n    if (ret as boolean) {\n      this.errors.push(...ret as ValidationError[]);\n    }\n  }\n\n  onopentag(node: SaxesTag): void {\n    const { attributes } = node;\n    const keys = Object.keys(attributes);\n    // Pre-allocate an array of the right size, instead of reallocating\n    // a bunch of times.\n    // tslint:disable-next-line:prefer-array-literal\n    const params: string[] = new Array(2 + keys.length);\n    params[0] = node.uri;\n    params[1] = node.local;\n    let ix = 2;\n    for (const name of keys) {\n      const { uri, local, value } = attributes[name] as SaxesAttribute;\n      // Skip XML namespace declarations\n      if (uri !== XMLNS_NAMESPACE) {\n        params[ix++] = uri;\n        params[ix++] = local;\n        params[ix++] = value;\n      }\n    }\n    this.fireEvent(\"startTagAndAttributes\", params);\n  }\n\n  onclosetag(node: SaxesTag): void {\n    this.fireEvent(\"endTag\", [node.uri, node.local]);\n  }\n\n  ontext(text: string): void {\n    this.fireEvent(\"text\", [text]);\n  }\n\n  onend(): void {\n    const result = this.walker.end();\n    if (result !== false) {\n      this.errors.push(...result);\n    }\n  }\n}\n\n// A validator that does not validate.\nclass NullValidator implements ValidatorI {\n  // tslint:disable-next-line:no-empty\n  onopentag(): void {}\n\n  // tslint:disable-next-line:no-empty\n  onclosetag(): void {}\n\n  // tslint:disable-next-line:no-empty\n  ontext(): void {}\n\n  // tslint:disable-next-line:no-empty\n  onend(): void {}\n}\n\n/**\n * A simple parser used for loading a XML document into memory.  Parsers of this\n * class use [[Node]] objects to represent the tree of nodes.\n */\nexport class BasicParser {\n  /**\n   * The stack of elements. At the end of parsing, there should be only one\n   * element on the stack, the root. This root is not an element that was in\n   * the XML file but a holder for the tree of elements. It has a single child\n   * which is the root of the actual file parsed.\n   */\n  protected readonly stack: { node: SaxesTag; children: ConcreteNode[],\n    documentation?: string }[];\n\n  protected readonly docStack: { node: SaxesTag; text: string }[];\n\n  protected drop: number = 0;\n\n  protected isAnnotation: boolean = false;\n\n  constructor(readonly saxesParser: SaxesParser,\n              protected readonly validator: ValidatorI = new NullValidator()) {\n    saxesParser.onopentag = this.onopentag.bind(this);\n    saxesParser.onclosetag = this.onclosetag.bind(this);\n    saxesParser.ontext = this.ontext.bind(this);\n    saxesParser.onend = this.onend.bind(this);\n    this.stack = [{\n      // We cheat. The node field of the top level stack item won't ever be\n      // accessed.\n      node: undefined as any,\n      children: [],\n    }];\n    this.docStack = [];\n  }\n\n  /**\n   * The root of the parsed XML.\n   */\n  get root(): Element {\n    return this.stack[0].children.filter(isElement)[0];\n  }\n\n  onopentag(node: SaxesTag): void {\n    // We have to validate the node even if we are not going to record it,\n    // because RelaxNG does not allow foreign nodes everywhere.\n    this.validator.onopentag(node);\n\n    // We can skip creating Element objects for foreign nodes and their\n    // children.\n    if ((node.uri !== RELAXNG_URI\n      && node.uri !== ANNOS_URI && node.uri !== XHTML_URI) || this.drop !== 0) {\n      this.drop++;\n\n      return;\n    }\n\n    if (node.uri === ANNOS_URI || node.uri === XHTML_URI) {\n      if (!this.isAnnotation) {\n        this.isAnnotation = true;\n        this.docStack.push({\n          node,\n          text: \"\",\n        });\n      } else {\n        this.drop++;\n      }\n    } else {\n      this.stack.push({\n        node,\n        children: [],\n      });\n    }\n\n  }\n\n  onclosetag(node: SaxesTag): void {\n    // We have to validate the node even if we are not going to record it,\n    // because RelaxNG does not allow foreign nodes everywhere.\n    this.validator.onclosetag(node);\n\n    if (this.drop !== 0) {\n      this.drop--;\n\n      return;\n    }\n\n    if (this.isAnnotation) {\n      if (this.docStack.length === 1) {\n        // Annotations must be either the first child\n        // or an immediate sibling of a value element\n\n        const topNode = this.stack[this.stack.length - 1];\n        const doc = this.docStack[this.docStack.length - 1].text;\n        const childrenEls = topNode.children.filter(child => child.kind === \"element\");\n\n        if (childrenEls.length === 0) {\n          // Assign doc to topNode if it doesn't yet have children.\n          topNode.documentation = doc;\n        } else {\n          const lastChild = childrenEls[childrenEls.length - 1] as Element;\n          if (lastChild.local === \"value\") {\n            // Assign to first child if it's a value.\n            lastChild.documentation = doc;\n          }\n        }\n      }\n      // tslint:disable-next-line: no-unused-expression\n      this.docStack.pop()!;\n      if (this.docStack.length === 0) {\n        this.isAnnotation = false;\n      }\n    } else {\n      // tslint:disable-next-line:no-non-null-assertion\n      const { node: topNode, children, documentation } = this.stack.pop()!;\n      this.stack[this.stack.length - 1].children\n        .push(Element.fromSax(topNode, children, documentation));\n    }\n  }\n\n  ontext(text: string): void {\n    this.validator.ontext(text);\n    if (this.drop !== 0) {\n      return;\n    }\n    if (this.isAnnotation) {\n      this.docStack[this.docStack.length - 1].text += text;\n    } else {\n      this.stack[this.stack.length - 1].children.push(new Text(text));\n    }\n  }\n\n  onend(): void {\n    this.validator.onend();\n  }\n}\n\n/**\n * This parser is specifically dedicated to the task of reading simplified Relax\n * NG schemas. In a Relax NG schema, text nodes that consist entirely of white\n * space are expendable, except in the ``param`` and ``value`` elements, where\n * they do potentially carry significant information.\n *\n * This parser strips nodes that consist entirely of white space because this\n * simplifies code that needs to process the resulting tree, but preserve those\n * nodes that are potentially significant.\n *\n * This parser does not allow elements which are not in the Relax NG namespace.\n */\nclass ConversionParser extends BasicParser {\n  onopentag(node: SaxesTag): void {\n    // tslint:disable-next-line: no-http-string\n    if (node.uri !== \"http://relaxng.org/ns/structure/1.0\") {\n      throw new Error(`node in unexpected namespace: ${node.uri}`);\n    }\n\n    super.onopentag(node);\n  }\n\n  ontext(text: string): void {\n    // We ignore text appearing before or after the top level element.\n    if (this.stack.length <= 1 || this.drop !== 0) {\n      return;\n    }\n\n    const top = this.stack[this.stack.length - 1];\n    const local = top.node.local;\n    // The parser does not allow non-RNG nodes, so we don't need to check the\n    // namespace.\n    const keepWhitespaceNodes = local === \"param\" || local === \"value\";\n\n    if (keepWhitespaceNodes || text.trim() !== \"\") {\n      super.ontext(text);\n    }\n  }\n}\n\nexport function parseSimplifiedSchema(fileName: string,\n                                      simplifiedSchema: string): Element {\n  const convParser = new ConversionParser(new SaxesParser({ xmlns: true,\n                                                            position: false,\n                                                            fileName }));\n  convParser.saxesParser.write(simplifiedSchema).close();\n\n  return convParser.root;\n}\n\n// Exception used to terminate the saxes parser early.\nclass Found extends Error {\n  constructor() {\n    super();\n    fixPrototype(this, Found);\n  }\n}\n\nclass IncludeParser {\n  constructor(readonly saxesParser: SaxesParser) {\n    saxesParser.onopentag = this.onopentag.bind(this);\n  }\n\n  onopentag(node: SaxesTag): void {\n    // tslint:disable-next-line:no-http-string\n    if (node.uri === \"http://relaxng.org/ns/structure/1.0\" &&\n        (node.local === \"include\" || node.local === \"externalRef\")) {\n      throw new Found();  // Stop early.\n    }\n  }\n}\n\n/**\n * Determine whether an RNG file depends on another file either through the use\n * of ``include`` or ``externalRef``.\n *\n * @param rng The RNG file to check.\n *\n * @returns ``true`` if dependent, ``false`` if not.\n */\nexport function dependsOnExternalFile(rng: string): boolean {\n  const parser =\n    new IncludeParser(new SaxesParser({ xmlns: true, position: false }));\n  let found = false;\n  try {\n    parser.saxesParser.write(rng).close();\n  }\n  catch (ex) {\n    if (!(ex instanceof Found)) {\n      throw ex;\n    }\n\n    found = true;\n  }\n\n  return found;\n}\n\n//  LocalWords:  MPL NG param RNG\n"]}