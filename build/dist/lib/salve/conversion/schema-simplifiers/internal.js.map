{"version":3,"file":"internal.js","sourceRoot":"","sources":["../../../../../../lib/salve/conversion/schema-simplifiers/internal.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A simplifier implemented in TypeScript (thus internal to Salve).\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { SaxesParser } from \"saxes\";\n\nimport { registry, ValueError, ValueValidationError } from \"../../datatypes\";\nimport { DefaultNameResolver } from \"../../default_name_resolver\";\nimport { readTreeFromJSON } from \"../../json-format/read\";\nimport { NameResolver } from \"../../name_resolver\";\nimport { AnyName, ConcreteName, Grammar, Name, NameChoice,\n         NsName } from \"../../patterns\";\nimport * as relaxng from \"../../schemas/relaxng.json\";\nimport { BasicParser, Element, Text, Validator } from \"../parser\";\nimport { ResourceLoader } from \"../resource-loader\";\nimport { ManifestEntry, registerSimplifier, SchemaSimplifierOptions,\n         SimplificationResult } from \"../schema-simplification\";\nimport { SchemaValidationError } from \"../schema-validation\";\nimport * as simplifier from \"../simplifier\";\nimport { findMultiDescendantsByLocalName } from \"../simplifier/util\";\nimport { BaseSimplifier } from \"./base\";\nimport { fromQNameToURI, localName } from \"./common\";\n\nfunction makeNamePattern(el: Element): ConcreteName {\n  switch (el.local) {\n    case \"name\":\n      return new Name(el.mustGetAttribute(\"ns\"), el.text, el.documentation);\n    case \"choice\":\n      return new NameChoice(makeNamePattern(el.children[0] as Element),\n                            makeNamePattern(el.children[1] as Element));\n    case \"anyName\": {\n      const first = el.children[0] as Element;\n\n      return new AnyName(first !== undefined ? makeNamePattern(first) :\n                         undefined);\n    }\n    case \"nsName\": {\n      const first = el.children[0] as Element;\n\n      return new NsName(el.mustGetAttribute(\"ns\"),\n                        first !== undefined ? makeNamePattern(first) :\n                        undefined);\n    }\n    case \"except\":\n      return makeNamePattern(el.children[0] as Element);\n    default:\n      throw new Error(`unexpected element in name pattern ${el.local}`);\n  }\n}\n\nconst enum ContentType {\n  EMPTY,\n  COMPLEX,\n  SIMPLE,\n}\n\ninterface State {\n  inAttribute: boolean;\n  inList: boolean;\n  inDataExcept: boolean;\n  inOneOrMore: boolean;\n  inOneOrMoreGroup: boolean;\n  inOneOrMoreInterleave: boolean;\n  inInterlave: boolean;\n  inGroup: boolean;\n}\n\nclass ProhibitedPath extends SchemaValidationError {\n  constructor(path: string) {\n    super(`prohibited path: ${path}`);\n  }\n}\n\nclass ProhibitedAttributePath extends SchemaValidationError {\n  constructor(name: string) {\n    super(`attribute//${name}`);\n  }\n}\n\nclass ProhibitedListPath extends SchemaValidationError {\n  constructor(name: string) {\n    super(`list//${name}`);\n  }\n}\n\nclass ProhibitedStartPath extends SchemaValidationError {\n  constructor(name: string) {\n    super(`start//${name}`);\n  }\n}\n\nclass ProhibitedDataExceptPath extends SchemaValidationError {\n  constructor(name: string) {\n    super(`data/except//${name}`);\n  }\n}\n\ninterface CheckResult {\n  readonly contentType: ContentType | null;\n\n  readonly occurringAttributeNames: ReadonlyArray<ConcreteName>;\n\n  // We considered making this variable a Set. Multiple ref of the same name are\n  // bound to happen in any schemas beyond trivial ones. However, the cost of\n  // maintaining Set objects negates the benefits that occur when checking\n  // interleave elements.\n  readonly occurringRefs: ReadonlyArray<Element>;\n\n  readonly occurringTexts: boolean;\n}\n\nconst EMPTY_ELEMENT_ARRAY: ReadonlyArray<Element> = [];\nconst EMPTY_NAME_ARRAY: ReadonlyArray<ConcreteName> = [];\n\nconst TEXT_RESULT: CheckResult = {\n  contentType: ContentType.COMPLEX,\n  occurringAttributeNames: EMPTY_NAME_ARRAY,\n  occurringRefs: EMPTY_ELEMENT_ARRAY,\n  occurringTexts: true,\n};\n\nconst EMPTY_RESULT: CheckResult = {\n  contentType: ContentType.EMPTY,\n  occurringAttributeNames: EMPTY_NAME_ARRAY,\n  occurringRefs: EMPTY_ELEMENT_ARRAY,\n  occurringTexts: false,\n};\n\nconst DATA_RESULT: CheckResult = {\n  contentType: ContentType.SIMPLE,\n  occurringAttributeNames: EMPTY_NAME_ARRAY,\n  occurringRefs: EMPTY_ELEMENT_ARRAY,\n  occurringTexts: false,\n};\n\nconst LIST_RESULT = DATA_RESULT;\nconst VALUE_RESULT = DATA_RESULT;\n\nconst NOT_ALLOWED_RESULT: CheckResult = {\n  contentType: null,\n  occurringAttributeNames: EMPTY_NAME_ARRAY,\n  occurringRefs: EMPTY_ELEMENT_ARRAY,\n  occurringTexts: false,\n};\n\nconst FORBIDDEN_IN_START = [\"attribute\", \"data\", \"value\", \"text\", \"list\",\n                            \"group\", \"interleave\", \"oneOrMore\", \"empty\"];\n\ntype Handler = (this: GeneralChecker, el: Element,\n                state: State) => CheckResult;\n\n/**\n * Perform the final constraint checks, and record some information\n * for checkInterleaveRestriction.\n */\nclass GeneralChecker {\n  private definesByName!: Map<string, Element>;\n  private readonly defineNameToElementNames: Map<string, ConcreteName> =\n    new Map();\n  readonly typeWarnings: string[] = [];\n\n  check(el: Element): void {\n    const { children } = el;\n\n    const definesByName = new Map<string, Element>();\n    for (let ix = 1; ix < children.length; ++ix) {\n      const child = children[ix] as Element;\n      definesByName.set(child.mustGetAttribute(\"name\"), child);\n    }\n    this.definesByName = definesByName;\n\n    const start = children[0] as Element;\n\n    const found = findMultiDescendantsByLocalName(start, FORBIDDEN_IN_START);\n    for (const forbidden of FORBIDDEN_IN_START) {\n      if (found[forbidden].length !== 0) {\n        throw new ProhibitedStartPath(forbidden);\n      }\n    }\n\n    const state = {\n      inAttribute: false,\n      inList: false,\n      inDataExcept: false,\n      inOneOrMore: false,\n      inOneOrMoreGroup: false,\n      inOneOrMoreInterleave: false,\n      inInterlave: false,\n      inGroup: false,\n    };\n\n    // The first child of <grammar> is necessarily <start>. So we handle\n    // start here.\n    this._check(start.children[0] as Element, state);\n\n    // The other children are necessarily <define>.\n    for (let ix = 1; ix < children.length; ++ix) {\n      // <define> elements necessarily have a single child which is an\n      // <element>.\n      const element = (children[ix] as Element).children[0] as Element;\n      // The first child is the name class, which we do not need to walk.\n      const pattern = element.children[1] as Element;\n      const { contentType } = this._check(pattern, state);\n      if (contentType === null && pattern.local !== \"notAllowed\") {\n        throw new SchemaValidationError(\n          `definition ${el.mustGetAttribute(\"name\")} violates the constraint \\\non string values (section 7.2)`);\n      }\n    }\n  }\n\n  private _check(el: Element, state: State): CheckResult {\n    return ((this as any)[`${el.local}Handler`] as Handler)\n      .call(this, el, state);\n  }\n\n  attributeHandler(el: Element, state: State): CheckResult {\n    if (state.inOneOrMoreGroup) {\n      throw new ProhibitedPath(\"oneOrMore//group//attribute\");\n    }\n\n    if (state.inOneOrMoreInterleave) {\n      throw new ProhibitedPath(\"oneOrMore//interleave//attribute\");\n    }\n\n    if (state.inAttribute) {\n      throw new ProhibitedAttributePath(el.local);\n    }\n\n    if (state.inList) {\n      throw new ProhibitedListPath(el.local);\n    }\n\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    const [first, second] = el.children as [Element, Element];\n    const name = makeNamePattern(first);\n    if (!state.inOneOrMore && !name.simple()) {\n      throw new SchemaValidationError(\"an attribute with an infinite name \\\nclass must be a descendant of oneOrMore (section 7.3)\");\n    }\n\n    // The first child is the name class, which we do not need to walk.\n    this._check(second, { ...state, inAttribute: true });\n\n    return {\n      contentType: ContentType.EMPTY,\n      occurringAttributeNames: [name],\n      occurringRefs: EMPTY_ELEMENT_ARRAY,\n      occurringTexts: false,\n    };\n  }\n\n  oneOrMoreHandler(el: Element, state: State): CheckResult {\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    const { contentType, occurringAttributeNames, occurringRefs,\n            occurringTexts } =\n      this._check(el.children[0] as Element, { ...state, inOneOrMore: true });\n\n    // The test would be\n    //\n    // ct !== null && groupable(ct, ct)\n    //\n    // but the only thing not groupable with itself is ContentType.SIMPLE\n    // and if ct === null then forcibly ct !== ContentType.SIMPLE\n    // is true so we can simplify to the following.\n    return {\n      contentType: contentType !== ContentType.SIMPLE ? contentType : null,\n      occurringAttributeNames,\n      occurringRefs,\n      occurringTexts,\n    };\n  }\n\n  groupHandler(el: Element, state: State): CheckResult {\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    return this.groupInterleaveHandler(\n      el.children as Element[],\n      {\n        ...state,\n        inGroup: true,\n        inOneOrMoreGroup: state.inOneOrMore,\n      },\n      false);\n  }\n\n  interleaveHandler(el: Element, state: State): CheckResult {\n    if (state.inList) {\n      throw new ProhibitedListPath(el.local);\n    }\n\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    return this.groupInterleaveHandler(\n      el.children as Element[],\n      {\n        ...state, inInterlave: true,\n        inOneOrMoreInterleave: state.inOneOrMore,\n      },\n      true);\n  }\n\n  choiceHandler(el: Element, state: State): CheckResult {\n    const { contentType: firstCt, occurringAttributeNames: firstAttributes,\n            occurringRefs: firstRefs, occurringTexts: firstTexts } =\n      this._check(el.children[0] as Element, state);\n    const { contentType: secondCt, occurringAttributeNames: secondAttributes,\n            occurringRefs: secondRefs, occurringTexts: secondTexts } =\n      this._check(el.children[1] as Element, state);\n\n    return {\n      contentType: firstCt !== null && secondCt !== null ?\n        (firstCt > secondCt ? firstCt : secondCt) : null,\n      occurringAttributeNames: firstAttributes.concat(secondAttributes),\n      occurringRefs: firstRefs.concat(secondRefs),\n      occurringTexts: firstTexts || secondTexts,\n    };\n  }\n\n  listHandler(el: Element, state: State): CheckResult {\n    if (state.inList) {\n      throw new ProhibitedListPath(el.local);\n    }\n\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    this._check(el.children[0] as Element, { ...state, inList: true });\n\n    return LIST_RESULT;\n  }\n\n  dataHandler(el: Element, state: State): CheckResult {\n    const typeAttr = el.mustGetAttribute(\"type\");\n    const libname = el.mustGetAttribute(\"datatypeLibrary\");\n    const lib = registry.find(libname);\n    if (lib === undefined) {\n      throw new ValueValidationError(\n        el.path, [new ValueError(`unknown datatype library: ${libname}`)]);\n    }\n\n    const datatype = lib.types[typeAttr];\n    if (datatype === undefined) {\n      throw new ValueValidationError(\n        el.path,\n        [new ValueError(`unknown datatype ${typeAttr} in \\\n${(libname === \"\") ? \"default library\" : `library ${libname}`}`)]);\n    }\n\n    const { children } = el;\n    if (children.length !== 0) {\n      const last = children[children.length - 1] as Element;\n      // We only need to scan the possible except child, which is necessarily\n      // last.\n      const hasExcept = last.local === \"except\";\n\n      const limit = hasExcept ? children.length - 1 : children.length;\n      // Running parseParams if we have no params is expensive. And if there are\n      // no params, there's nothing to check so don't run parseParams without\n      // params.\n      if (limit > 0) {\n        const params: { name: string; value: string }[] = [];\n        for (let ix = 0; ix < limit; ++ix) {\n          const child = children[ix] as Element;\n          params.push({\n            name: child.mustGetAttribute(\"name\"),\n            value: child.text,\n          });\n        }\n\n        datatype.parseParams(el.path, params);\n      }\n\n      if (hasExcept) {\n        this._check(last.children[0] as Element,\n                    state.inDataExcept ? state :\n                    { ...state, inDataExcept: true });\n      }\n    }\n\n    // tslint:disable-next-line: no-http-string\n    if (libname === \"http://www.w3.org/2001/XMLSchema-datatypes\" &&\n        (typeAttr === \"ENTITY\" || typeAttr === \"ENTITIES\")) {\n      this.typeWarnings.push(\n        `WARNING: ${el.path} uses the ${typeAttr} type in library \\\n${libname}`);\n    }\n\n    return DATA_RESULT;\n  }\n\n  valueHandler(el: Element, state: State): CheckResult {\n    const typeAttr = el.mustGetAttribute(\"type\");\n    const libname = el.mustGetAttribute(\"datatypeLibrary\");\n    let ns = el.mustGetAttribute(\"ns\");\n\n    const lib = registry.find(libname);\n    if (lib === undefined) {\n      throw new ValueValidationError(\n        el.path,\n        [new ValueError(`unknown datatype library: ${libname}`)]);\n    }\n\n    const datatype = lib.types[typeAttr];\n    if (datatype === undefined) {\n      throw new ValueValidationError(\n        el.path,\n        [new ValueError(`unknown datatype ${typeAttr} in \\\n${(libname === \"\") ? \"default library\" : `library ${libname}`}`)]);\n    }\n\n    let value = el.text;\n    let context: { resolver: NameResolver } | undefined;\n    if (datatype.needsContext) {\n      // Change ns to the namespace we need.\n      ns = fromQNameToURI(value, el);\n      value = localName(value);\n      el.setAttribute(\"ns\", ns);\n      el.replaceContent([new Text(value)]);\n\n      const nr = new DefaultNameResolver();\n      nr.definePrefix(\"\", ns);\n      context = { resolver: nr };\n    }\n\n    datatype.parseValue(el.path, value, context);\n\n    // tslint:disable-next-line: no-http-string\n    if (libname === \"http://www.w3.org/2001/XMLSchema-datatypes\" &&\n        (typeAttr === \"ENTITY\" || typeAttr === \"ENTITIES\")) {\n      this.typeWarnings.push(\n        `WARNING: ${el.path} uses the ${typeAttr} type in library \\\n${libname}`);\n    }\n\n    return VALUE_RESULT;\n  }\n\n  textHandler(el: Element, state: State): CheckResult {\n    if (state.inList) {\n      throw new ProhibitedListPath(el.local);\n    }\n\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    return TEXT_RESULT;\n  }\n\n  refHandler(el: Element, state: State): CheckResult {\n    if (state.inList) {\n      throw new ProhibitedListPath(el.local);\n    }\n\n    if (state.inAttribute) {\n      throw new ProhibitedAttributePath(el.local);\n    }\n\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    return {\n      contentType: ContentType.COMPLEX,\n      occurringAttributeNames: EMPTY_NAME_ARRAY,\n      occurringRefs: [el],\n      occurringTexts: false,\n    };\n  }\n\n  emptyHandler(el: Element, state: State): CheckResult {\n    if (state.inDataExcept) {\n      throw new ProhibitedDataExceptPath(el.local);\n    }\n\n    return EMPTY_RESULT;\n  }\n\n  notAllowedHandler(): CheckResult {\n    return NOT_ALLOWED_RESULT;\n  }\n\n  private getElementNamesForDefine(name: string): ConcreteName {\n    let pattern = this.defineNameToElementNames.get(name);\n    if (pattern === undefined) {\n      const def = this.definesByName.get(name);\n      // tslint:disable-next-line:no-non-null-assertion\n      const element = def!.children[0] as Element;\n      const namePattern = element.children[0] as Element;\n      pattern = makeNamePattern(namePattern);\n      this.defineNameToElementNames.set(name, pattern);\n    }\n\n    return pattern;\n  }\n\n  private groupInterleaveHandler(children: Element[],\n                                 newState: State,\n                                 isInterleave: boolean): CheckResult {\n    const { contentType: firstCt, occurringAttributeNames: firstAttributes,\n            occurringRefs: firstRefs, occurringTexts: firstTexts} =\n      this._check(children[0], newState);\n    const { contentType: secondCt, occurringAttributeNames: secondAttributes,\n            occurringRefs: secondRefs, occurringTexts: secondTexts} =\n      this._check(children[1], newState);\n\n    for (const attr1 of firstAttributes) {\n      for (const attr2 of secondAttributes) {\n        if (attr1.intersects(attr2)) {\n          throw new SchemaValidationError(\n            `the name classes of two attributes in the same group or\ninterleave intersect (section 7.3): ${attr1} and ${attr2}`);\n        }\n      }\n    }\n\n    if (isInterleave) {\n      if (firstTexts && secondTexts) {\n        throw new SchemaValidationError(\n          \"text present in both patterns of an interleave (section 7.4)\");\n      }\n\n      for (const ref1 of firstRefs) {\n        const name1 =\n          this.getElementNamesForDefine(ref1.mustGetAttribute(\"name\"));\n        for (const ref2 of secondRefs) {\n          const name2 =\n            this.getElementNamesForDefine(ref2.mustGetAttribute(\"name\"));\n          if (name1.intersects(name2)) {\n            throw new SchemaValidationError(`name classes of elements in both \\\npatterns of an interleave intersect (section 7.4): ${name1} and ${name2}`);\n          }\n        }\n      }\n    }\n\n    // These tests combine the groupable(firstCt, secondCt) test together with\n    // the requirement that we return the content type which is the greatest.\n    let contentType: ContentType | null;\n    if (firstCt === ContentType.COMPLEX && secondCt === ContentType.COMPLEX) {\n      contentType = ContentType.COMPLEX;\n    }\n    else if (firstCt === ContentType.EMPTY) {\n      contentType = secondCt;\n    }\n    else {\n      contentType = (secondCt === ContentType.EMPTY) ? firstCt : null;\n    }\n\n    return {\n      contentType,\n      occurringAttributeNames: firstAttributes.concat(secondAttributes),\n      occurringRefs: firstRefs.concat(secondRefs),\n      occurringTexts: firstTexts || secondTexts,\n    };\n  }\n}\n\nlet cachedGrammar: Grammar | undefined;\n\nfunction getGrammar(): Grammar {\n  if (cachedGrammar === undefined) {\n    cachedGrammar = readTreeFromJSON(relaxng);\n  }\n\n  return cachedGrammar;\n}\n\n/**\n * A simplifier implemented in TypeScript (thus internal to Salve).\n */\nexport class InternalSimplifier<RL extends ResourceLoader>\n  extends BaseSimplifier {\n  static validates: true = true;\n  static createsManifest: true = true;\n\n  private lastStepStart?: number;\n  private readonly manifestPromises: PromiseLike<ManifestEntry>[] = [];\n\n  constructor(options: SchemaSimplifierOptions<RL>) {\n    super(options);\n    if (options.timing) {\n      options.verbose = true;\n    }\n  }\n\n  private async parse(filePath: URL): Promise<Element> {\n    const schemaResource = await this.options.resourceLoader.load(filePath);\n    const schemaText = await schemaResource.getText();\n    const fileName = filePath.toString();\n    const saxesParser = new SaxesParser({ xmlns: true,\n                                          position: false,\n                                          fileName });\n    let validator: Validator | undefined;\n    if (this.options.validate) {\n      validator = new Validator(getGrammar(), saxesParser);\n    }\n\n    const parser = new BasicParser(saxesParser, validator);\n    parser.saxesParser.write(schemaText);\n    parser.saxesParser.close();\n\n    if (validator !== undefined) {\n      if (validator.errors.length !== 0) {\n        const message = validator.errors.map(x => x.toString()).join(\"\\n\");\n        throw new SchemaValidationError(message);\n      }\n    }\n\n    if (this.options.createManifest) {\n      const algo = this.options.manifestHashAlgorithm;\n      if (typeof algo === \"string\") {\n        this.manifestPromises.push((async () => {\n          const digest =\n            // tslint:disable-next-line:await-promise\n            await crypto.subtle.digest(algo,\n                                       new TextEncoder().encode(schemaText));\n\n          const arr = new Uint8Array(digest);\n          let hash = `${algo}-`;\n          for (const x of arr) {\n            const hex = x.toString(16);\n            hash += x > 0xF ? hex : `0${hex}`;\n          }\n\n          return { filePath: fileName, hash };\n        })());\n      }\n      else {\n        this.manifestPromises.push((async () => {\n          const hash = await algo(schemaResource);\n\n          return { filePath: fileName, hash };\n        })());\n      }\n    }\n\n    return parser.root;\n  }\n\n  stepStart(no: number): void {\n    this.stepTiming();\n    if (this.options.verbose) {\n      // tslint:disable-next-line:no-console\n      console.log(`Simplification step ${no}`);\n    }\n  }\n\n  stepTiming(): void {\n    if (!this.options.timing) {\n      return;\n    }\n\n    if (this.lastStepStart !== undefined) {\n      // tslint:disable-next-line:no-console\n      console.log(`${Date.now() - this.lastStepStart}ms`);\n      this.lastStepStart = undefined;\n    }\n\n    this.lastStepStart = Date.now();\n  }\n\n  async simplify(schemaPath: URL): Promise<SimplificationResult> {\n    let startTime: number | undefined;\n    if (this.options.verbose) {\n      // tslint:disable-next-line:no-console\n      console.log(\"Simplifying...\");\n      if (this.options.timing) {\n        startTime = Date.now();\n      }\n    }\n\n    let warnings: string[] = [];\n    let tree!: Element;\n\n    if (this.options.simplifyTo >= 1) {\n      this.stepStart(1);\n      tree = await this.parse(schemaPath);\n      tree = await simplifier.step1(schemaPath, tree, this.parse.bind(this));\n    }\n\n    if (this.options.simplifyTo >= 4) {\n      this.stepStart(4);\n      tree = simplifier.step4(tree);\n    }\n\n    if (this.options.simplifyTo >= 6) {\n      this.stepStart(6);\n      tree = simplifier.step6(tree);\n    }\n\n    if (this.options.simplifyTo >= 9) {\n      this.stepStart(9);\n      tree = simplifier.step9(tree);\n    }\n\n    if (this.options.simplifyTo >= 10) {\n      this.stepStart(10);\n      tree = simplifier.step10(tree, this.options.validate);\n    }\n\n    if (this.options.simplifyTo >= 14) {\n      this.stepStart(14);\n      tree = simplifier.step14(tree);\n    }\n\n    if (this.options.simplifyTo >= 15) {\n      this.stepStart(15);\n      tree = simplifier.step15(tree);\n    }\n\n    if (this.options.simplifyTo >= 16) {\n      this.stepStart(16);\n      tree = simplifier.step16(tree);\n    }\n\n    if (this.options.simplifyTo >= 17) {\n      this.stepStart(17);\n      tree = simplifier.step17(tree);\n    }\n\n    if (this.options.simplifyTo >= 18) {\n      this.stepStart(18);\n      tree = simplifier.step18(tree);\n      if (this.options.validate) {\n        let checkStart: number | undefined;\n        if (this.options.timing) {\n          checkStart = Date.now();\n        }\n\n        const checker = new GeneralChecker();\n        checker.check(tree);\n        warnings = checker.typeWarnings;\n\n        if (this.options.timing) {\n          // tslint:disable-next-line:no-non-null-assertion no-console\n          console.log(`Step 18 check delta: ${Date.now() - checkStart!}`);\n        }\n      }\n    }\n\n    if (this.options.timing) {\n      this.stepTiming(); // Output the last timing.\n      // tslint:disable-next-line:no-non-null-assertion no-console\n      console.log(`Simplification delta: ${Date.now() - startTime!}`);\n    }\n\n    return {\n      simplified: tree,\n      warnings,\n      manifest: await Promise.all(this.manifestPromises),\n    };\n  }\n}\n\nregisterSimplifier(\"internal\", InternalSimplifier);\n"]}