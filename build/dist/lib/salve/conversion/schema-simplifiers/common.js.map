{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../../../../lib/salve/conversion/schema-simplifiers/common.ts"],"names":[],"mappings":"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","sourcesContent":["import * as datatypes from \"../../datatypes\";\nimport { Data, Value } from \"../../patterns\";\nimport { Element, isElement, Text } from \"../parser\";\n\nconst warnAboutTheseTypes: string[] = [\n  \"ENTITY\",\n  \"ENTITIES\",\n];\n\n/**\n * @private\n *\n * @param el Element to start the search from.\n *\n * @returns ``true`` if ``el`` is an attribute or is in an RNG\n * ``<attribute>`` element. ``false`` otherwise.\n */\nfunction inAttribute(el: Element): boolean {\n  let current: Element | undefined = el;\n  while (current !== undefined) {\n    if (current.local === \"attribute\") {\n      return true;\n    }\n    current = current.parent;\n  }\n\n  return false;\n}\n\nexport function localName(value: string): string {\n  const sep = value.indexOf(\":\");\n\n  return (sep === -1) ? value : value.slice(sep + 1);\n}\n\nexport function fromQNameToURI(value: string, el: Element): string {\n  const colon = value.indexOf(\":\");\n\n  let prefix: string;\n  if (colon === -1) { // If there is no prefix\n    if (inAttribute(el)) { // Attribute in undefined namespace\n      return \"\";\n    }\n\n    // We are searching for the default namespace currently in effect.\n    prefix = \"\";\n  }\n  else {\n    prefix = value.substr(0, colon);\n    if (value.lastIndexOf(\":\") !== colon) {\n      throw new Error(\"invalid name\");\n    }\n  }\n\n  if (prefix === \"\") {\n    // Yes, we return the empty string even if that what @ns is set to:\n    // there is no default namespace when @ns is set to ''.\n    return el.mustGetAttribute(\"ns\");\n  }\n\n  //\n  // We have a prefix, in which case @ns is useless. We have to get the\n  // namespace from the namespaces declared in the XML file that contains the\n  // schema. At this stage, @xmlns and @xmlns:prefix attributes should no longer\n  // be available available. So we just ask the element to use its internal\n  // namespace data to resolve the prefix.\n  //\n  // (Note: in fact in the current implementation of the simplifiers the xmlns\n  // nodes are still available. The XSLT simplifier *cannot* carry the namespace\n  // information we need without keeping those nodes around, or producing a\n  // workaround. The internal simplifier does the same thing as the XSLT\n  // simplifier for ease of debugging (we can expect the same results from\n  // both). However... in any case the information is available through the\n  // namespace information stored on the nodes. So...)\n  //\n  const uri = el.resolve(prefix);\n  if (uri === undefined) {\n    throw new Error(`cannot resolve prefix: ${prefix}`);\n  }\n\n  return uri;\n}\n\n/**\n * This walker checks that the types used in the tree can be used, and does\n * special processing for ``QName`` and ``NOTATION``.\n */\nexport class DatatypeProcessor {\n  /**\n   * The warnings generated during the walk. This array is populated while\n   * walking.\n   */\n  readonly warnings: string[] = [];\n\n  // tslint:disable-next-line:max-func-body-length\n  walk(el: Element): void {\n    let libname: string | undefined;\n    let type: string | undefined; // tslint:disable-line: no-reserved-keywords\n\n    const name = el.local;\n    switch (name) {\n      case \"value\": {\n        let value = el.text;\n        type = el.mustGetAttribute(\"type\");\n        libname = el.mustGetAttribute(\"datatypeLibrary\");\n        let ns = el.mustGetAttribute(\"ns\");\n\n        const lib = datatypes.registry.find(libname);\n        if (lib === undefined) {\n          throw new datatypes.ValueValidationError(el.path,\n            [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);\n        }\n\n        const datatype = lib.types[type];\n        if (datatype === undefined) {\n          throw new datatypes.ValueValidationError(el.path,\n            [new datatypes.ValueError(`unknown datatype ${type} in \\\n${(libname === \"\") ? \"default library\" : `library ${libname}`}`)]);\n        }\n\n        if (datatype.needsContext &&\n            // tslint:disable-next-line: no-http-string\n            !(libname === \"http://www.w3.org/2001/XMLSchema-datatypes\" &&\n              (type === \"QName\" || type === \"NOTATION\"))) {\n          throw new Error(\"datatype needs context but is not QName or NOTATION \\\nform the XML Schema library: don't know how to handle\");\n        }\n\n        if (datatype.needsContext) {\n          // Change ns to the namespace we need.\n          ns = fromQNameToURI(value, el);\n          value = localName(value);\n          el.setAttribute(\"ns\", ns);\n          el.replaceContent([new Text(value)]);\n        }\n\n        const valuePattern = new Value(el.path, value, type, libname,\n          ns, el.documentation);\n\n        // Accessing the value will cause it to be validated.\n        // tslint:disable-next-line:no-unused-expression\n        valuePattern.value;\n        break;\n      }\n      case \"data\": {\n        // Except is necessarily last.\n        const hasExcept = (el.children.length !== 0 &&\n                           (el.children[el.children.length - 1] as Element)\n                           .local === \"except\");\n\n        type = el.mustGetAttribute(\"type\");\n        libname = el.mustGetAttribute(\"datatypeLibrary\");\n        const lib = datatypes.registry.find(libname);\n        if (lib === undefined) {\n          throw new datatypes.ValueValidationError(el.path,\n            [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);\n        }\n\n        if (lib.types[type] === undefined) {\n          throw new datatypes.ValueValidationError(el.path,\n            [new datatypes.ValueError(`unknown datatype ${type} in \\\n${(libname === \"\") ? \"default library\" : `library ${libname}`}`)]);\n        }\n\n        const params = el.children.slice(\n          0, hasExcept ? el.children.length - 1 : undefined).map(\n            (child: Element) => ({\n              name: child.mustGetAttribute(\"name\"),\n              value: child.text,\n            }));\n\n        const data = new Data(el.path, type, libname, params);\n\n        // This causes the parameters to be checked. We do not need to do\n        // anything with the value.\n        // tslint:disable-next-line:no-unused-expression\n        data.params;\n        break;\n      }\n      default:\n    }\n\n    // tslint:disable-next-line: no-http-string\n    if (libname === \"http://www.w3.org/2001/XMLSchema-datatypes\" &&\n        // tslint:disable-next-line:no-non-null-assertion\n        warnAboutTheseTypes.includes(type!)) {\n      this.warnings.push(\n        `WARNING: ${el.path} uses the ${type} type in library ${libname}`);\n    }\n\n    for (const child of el.children) {\n      if (isElement(child)) {\n        this.walk(child);\n      }\n    }\n  }\n}\n"]}