{"version":3,"file":"serializer.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/serializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Serialization support for trees produced by the {@link\n * module:conversion/parser parser} module.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright 2013, 2014 Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"./parser\";\n\n//\n// WARNING: This serializer is *not* meant to be able to handle all possible XML\n// under the sun. Don't export this code into another project.\n//\n// In fact it used only for testing conversion code. We keep it as part of the\n// library so that it is available for possible diagnostic tools but it is\n// really not meant to be used as part of normal salve operations.\n//\n// In particular, the logic in here is very dependent on how the code in its\n// sibling module parser.js constructs a tree of elements.\n//\n\nexport interface SerializationOptions {\n  /** Whether to pretty print the results. */\n  prettyPrint?: boolean;\n}\n\ninterface NormalizedSerializationOptions {\n  /** Whether to pretty print the results. */\n  prettyPrint: boolean;\n}\n\n/**\n * Serialize a tree previously produced by [[\"conversion/parser\".BasicParser]].\n *\n * @param tree The tree to serialize.\n *\n * @param options Options specifying how to perform the serialization.\n *\n * @returns The serialized tree.\n */\nexport function serialize(tree: Element,\n                          options: SerializationOptions = {}): string {\n  const normalized: NormalizedSerializationOptions = {\n    prettyPrint: options.prettyPrint === true,\n  };\n  let out = `<?xml version=\"1.0\"?>\\n${_serialize(false, \"\", tree, normalized)}`;\n\n  if (out[out.length - 1] !== \"\\n\") {\n    out += \"\\n\";\n  }\n\n  return out;\n}\n\n/**\n * Escape characters that cannot be represented literally in XML.\n *\n * @param text The text to escape.\n *\n * @param isAttr Whether the text is part of an attribute.\n *\n * @returns The escaped text.\n */\nfunction escape(text: string, isAttr: boolean): string {\n  // Even though the > escape is not *mandatory* in all cases, we still do it\n  // everywhere.\n  let ret = text.replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n\n  if (isAttr) {\n    ret = ret.replace(/\"/g, \"&quot;\");\n  }\n\n  return ret;\n}\n\n/**\n * Serialize an element and its children, recursively.\n *\n * @param mixed Whether or not the element being converted is in mixed contents.\n *\n * @param curIndent The current indentation. This is represented as a string of\n * white spaces.\n *\n * @param el The element to serialize.\n *\n * @param options Options specifying how to perform the serialization.\n *\n * @returns The serialization.\n */\nfunction _serialize(mixed: boolean,\n                    curIndent: string,\n                    el: Element,\n                    options: NormalizedSerializationOptions): string {\n  let buf = \"\";\n\n  buf += `${curIndent}<${el.local}`;\n  const attrs = el.getRawAttributes();\n  const names = Object.keys(attrs);\n  names.sort();\n  for (const name of names) {\n    buf += ` ${name}=\"${escape(el.mustGetAttribute(name), true)}\"`;\n  }\n  if (el.children.length === 0) {\n    buf += \"/>\";\n  }\n  else {\n    let childrenMixed = false;\n    for (const child of el.children) {\n      if (child.kind === \"text\") {\n        childrenMixed = true;\n        break;\n      }\n    }\n\n    buf += \">\";\n    if (options.prettyPrint && !childrenMixed) {\n      buf += \"\\n\";\n    }\n\n    const childIndent = options.prettyPrint ? `${curIndent}  ` : \"\";\n\n    for (const child of el.children) {\n      buf += child.kind === \"text\" ? escape(child.text, false) :\n        _serialize(childrenMixed, childIndent, child, options);\n    }\n\n    if (!childrenMixed) {\n      buf += curIndent;\n    }\n\n    buf += `</${el.local}>`;\n  }\n\n  if (options.prettyPrint && !mixed) {\n    buf += \"\\n\";\n  }\n\n  return buf;\n}\n"]}