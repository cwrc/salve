{"version":3,"file":"schema-simplification.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/schema-simplification.ts"],"names":[],"mappings":";;;AA2HA,MAAM,oBAAoB,GACxB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAEtB,SAAgB,uBAAuB;IACrC,OAAO,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;AAC3C,CAAC;AAFD,0DAEC;AAED,SAAgB,WAAW,CAAC,IAAY;IACtC,OAAO,oBAAoB,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;AAClD,CAAC;AAFD,kCAEC;AAED,SAAgB,kBAAkB,CAAC,IAAY,EACZ,IAA0B;IAC3D,oBAAoB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACpC,CAAC;AAHD,gDAGC;AAED,SAAgB,cAAc,CAC5B,IAAY,EACZ,OAAoC;IAEpC,MAAM,IAAI,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;IACxC,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,4BAA4B,IAAI,EAAE,CAAC,CAAC;KACrD;IAED,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3B,CAAC;AAVD,wCAUC","sourcesContent":["/**\n * Facilities for simplifying a schema.\n *\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"./parser\";\nimport { Resource, ResourceLoader } from \"./resource-loader\";\n\nexport type HashFunction<R extends Resource = Resource> =\n  (resource: R) => Promise<string>;\n\nexport interface SchemaSimplifierOptions\n  <RL extends ResourceLoader = ResourceLoader> {\n  /** True if the simplification should run verbosely. */\n  verbose: boolean;\n\n  /** True if timing information should be provided (implies verbose). */\n  timing: boolean;\n\n  /** True if temporary files should be preserved. */\n  keepTemp: boolean;\n\n  /** The step at which to stop simplification. */\n  simplifyTo: number;\n\n  /** The resource loader to use if resources are needed. */\n  resourceLoader: RL;\n\n  /** A function that creates a temporary directory and returns the path. */\n  ensureTempDir?(): string;\n\n  /**\n   * Validate while simplifying. It is an error to set this true for a\n   * simplifier that does not validate.\n   */\n  validate: boolean;\n\n  /**\n   * Create a manifest while simplifying. It is an error to set this true for a\n   * simplifier that does not support manifests.\n   */\n  createManifest: boolean;\n\n  /**\n   * Either a hash function or the name of an algorithm to use for hashing the\n   * source.\n   *\n   * If a string, then the string is the name of the algorithm to use for\n   * creating the hashes in the manifest. The supported names are those of the\n   * [``SubtleCrypto.digest()``][1] function.\n   *\n   * [1]: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n   *\n   * Security note: It is up to you to decide what strength hash you need. **The\n   * manifest is not designed for the sake of providing security.** So its\n   * hashes are not designed to detect willful tampering but rather to quickly\n   * determine whether a schema was edited. In the vast majority of real world\n   * usage scenarios, using a stronger hash would not provide better security\n   * because if an attacker can replace a schema with their own file, they also\n   * can access the manifest and replace the hash.\n   */\n  manifestHashAlgorithm: string | HashFunction;\n}\n\n/**\n * An entry in a manifest of files read during simplification.\n */\nexport interface ManifestEntry {\n  /** The path of the file. */\n  filePath: string;\n\n  /**\n   * The hash of the file. Hashes are stored in the following format:\n   *\n   * ``<algorithm name>-<hex hash value>``\n   *\n   * So if you used ``\"SHA-1\"``, the hash would look like\n   * ``\"SHA-1-deadbeef[...]\"``.\n   */\n  hash: string;\n}\n\nexport interface SimplificationResult {\n  /** The top-level element of the simplified tree. */\n  simplified: Element;\n\n  /** Warnings that may have come up during simplification. */\n  warnings: string[];\n\n  /**\n   * A manifest of the files read and their associated checksums. Some\n   * simplifiers do not support producing manifests and will have an array. O\n   * Otherwise, all files are in the array, including the initial schema file.\n   */\n  manifest: ManifestEntry[];\n}\n\n/** The interface that all simplifiers must follow. */\nexport interface SchemaSimplifier {\n  /**\n   * Simplify the schema at tree.\n   *\n   * @param schemaPath The path of the file to simplify. See [[ResourceLoader]]\n   * regarding limitations.\n   *\n   * @returns The result of simplification.\n   */\n  simplify(schemaPath: URL): Promise<SimplificationResult>;\n}\n\nexport interface SchemaSimplifierCtor\n  <RL extends ResourceLoader = ResourceLoader> {\n  /** True if this simplifier validates the schema as it simplifies. */\n  validates: boolean;\n\n  /** True if this simplifier can create a file manifest. */\n  createsManifest: boolean;\n\n  new (options: SchemaSimplifierOptions<RL>): SchemaSimplifier;\n}\n\nconst availableSimplifiers: Record<string, SchemaSimplifierCtor> =\n  Object.create(null);\n\nexport function getAvailableSimplifiers(): string [] {\n  return Object.keys(availableSimplifiers);\n}\n\nexport function isAvailable(name: string): boolean {\n  return availableSimplifiers[name] !== undefined;\n}\n\nexport function registerSimplifier(name: string,\n                                   ctor: SchemaSimplifierCtor): void {\n  availableSimplifiers[name] = ctor;\n}\n\nexport function makeSimplifier<RL extends ResourceLoader>(\n  name: string,\n  options: SchemaSimplifierOptions<RL>):\nSchemaSimplifier {\n  const ctor = availableSimplifiers[name];\n  if (ctor === undefined) {\n    throw new Error(`unknown simplifier name: ${name}`);\n  }\n\n  return new ctor(options);\n}\n"]}