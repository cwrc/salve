{"version":3,"file":"schema-validation.js","sourceRoot":"","sources":["../../../../../lib/salve/conversion/schema-validation.ts"],"names":[],"mappings":";;;AAUA,oCAAwC;AAcxC,MAAa,qBAAsB,SAAQ,KAAK;IAC9C,YAAY,OAAe;QACzB,KAAK,EAAE,CAAC;QAER,MAAM,GAAG,GAAU,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;QACtC,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;QACpC,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;QAC3B,oBAAY,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;IAC5C,CAAC;CACF;AAVD,sDAUC;AA8BD,MAAM,mBAAmB,GACvB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAEtB,SAAgB,sBAAsB;IACpC,OAAO,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;AAC1C,CAAC;AAFD,wDAEC;AAED,SAAgB,oBAAoB,CAAC,IAAY;IAC/C,OAAO,mBAAmB,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;AACjD,CAAC;AAFD,oDAEC;AAED,SAAgB,iBAAiB,CAAC,IAAY,EACZ,IAAyB;IACzD,mBAAmB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACnC,CAAC;AAHD,8CAGC;AAED,SAAgB,aAAa,CAAC,IAAY,EACZ,OAA0C;IAEtE,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACvC,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,EAAE,CAAC,CAAC;KACpD;IAED,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3B,CAAC;AATD,sCASC","sourcesContent":["/**\n * Facilities for validating a schema before conversion.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\nimport { Element } from \"./parser\";\nimport { ResourceLoader } from \"./resource-loader\";\nimport { SchemaSimplifierOptions } from \"./schema-simplification\";\n\nimport { fixPrototype } from \"../tools\";\n\n/** Results of a schema validation. */\nexport interface SchemaValidationResult {\n  /**\n   * A simplified version of the schema. Some validators perform simplification\n   * *as part* of validating the schema, and may provide the simplified schema\n   * as a result of validation.\n   */\n  simplified?: Element;\n\n  warnings?: string[];\n}\n\nexport class SchemaValidationError extends Error {\n  constructor(message: string) {\n    super();\n\n    const err: Error = new Error(message);\n    this.name = \"SchemaValidationError\";\n    this.stack = err.stack;\n    this.message = err.message;\n    fixPrototype(this, SchemaValidationError);\n  }\n}\n\nexport interface SchemaValidatorOptions {\n  /** True if the validator should run verbosely. */\n  verbose: boolean;\n\n  /** The resource loader to use if resources are needed. */\n  resourceLoader: ResourceLoader;\n}\n\nexport interface SimplifyingSchemaValidatorOptions\nextends SchemaValidatorOptions, SchemaSimplifierOptions {}\n\n/** The interface that all validators must follow. */\nexport interface SchemaValidator {\n  /**\n   * Validate the schema located at ``path``.\n   *\n   * @param schemaPath The path of the file to simplify. See [[ResourceLoader]]\n   * regarding limitations.\n   *\n   * @returns The result of validation. The promise resolving at all indicates\n   * that the schema is valid. A failure is reported through a rejection.\n   */\n  validate(schemaPath: URL): Promise<SchemaValidationResult>;\n}\n\nexport type SchemaValidatorCtor =\n  new (options: SimplifyingSchemaValidatorOptions) => SchemaValidator;\n\nconst availableValidators: Record<string, SchemaValidatorCtor> =\n  Object.create(null);\n\nexport function getAvailableValidators(): string [] {\n  return Object.keys(availableValidators);\n}\n\nexport function isValidatorAvailable(name: string): boolean {\n  return availableValidators[name] !== undefined;\n}\n\nexport function registerValidator(name: string,\n                                  ctor: SchemaValidatorCtor): void {\n  availableValidators[name] = ctor;\n}\n\nexport function makeValidator(name: string,\n                              options: SimplifyingSchemaValidatorOptions):\nSchemaValidator {\n  const ctor = availableValidators[name];\n  if (ctor === undefined) {\n    throw new Error(`unknown validator name: ${name}`);\n  }\n\n  return new ctor(options);\n}\n"]}