{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../lib/salve/parse.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A parser used for testing.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\"use strict\";\nimport fileUrl from \"file-url\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { SaxesAttribute, SaxesParser, SaxesTag } from \"saxes\";\n\nimport { convertRNGToPattern, DefaultNameResolver, Grammar,\n         readTreeFromJSON } from \"./validate\";\n\n// tslint:disable no-console\n\nconst parser = new SaxesParser({ xmlns: true });\n\ntype TagInfo = {\n  uri: string;\n  local: string;\n  hasContext: boolean;\n};\n\nasync function grammarFromSource(rngSource: string | Grammar):\nPromise<Grammar> {\n  if (rngSource instanceof Grammar) {\n    return rngSource;\n  }\n\n  const rngSourceContent = fs.readFileSync(path.resolve(rngSource),\n                                           \"utf8\").toString();\n  // We try loading the tree as a JSON file. It may not work if the file is not\n  // actually JSON.\n  let obj: {} | undefined;\n  try {\n    obj = JSON.parse(rngSourceContent);\n  }\n  // tslint:disable-next-line:no-empty\n  catch {}\n\n  if (obj !== undefined) {\n    return readTreeFromJSON(obj);\n  }\n\n  // Treat it as a Relax NG schema.\n  return (await convertRNGToPattern(new URL(fileUrl(rngSource)))).pattern;\n}\n\n/**\n * Parse an XML file and validate it against a schema. This function is meant\n * for **illustration purposes** and is used in testing. It does cut\n * corners. You should not use this for production code.\n *\n * @param rngSource It may be a [[Grammar]] object pre-built from the Relax NG\n * schema you want to use. Or it can be a JSON string, which is the contents of\n * a file created with ``salve-convert``. Or it can be a path to a local file.\n *\n * @param xmlSource The XML contents to parse and validate.\n *\n * @param mute If true, don't report errors verbosely.\n *\n * @returns A promise resolving ``true`` if there were errors, ``false``\n * otherwise.\n */\n// tslint:disable-next-line: max-func-body-length\nexport async function parse(rngSource: string | Grammar,\n                            xmlSource: string,\n                            mute: boolean): Promise<boolean> {\n  // tslint:disable-next-line:no-parameter-reassignment\n  mute = !!mute;\n\n  const tree = await grammarFromSource(rngSource);\n\n  const nameResolver = new DefaultNameResolver();\n  const walker = tree.newWalker(nameResolver);\n\n  let error = false;\n\n  function fireEvent(name: string, args: any[]): void {\n    const ret = walker.fireEvent(name, args);\n    if (ret instanceof Array) {\n      error = true;\n      if (!mute) {\n        for (const err of ret) {\n          console.log(`on event ${name}, ${args.join(\", \")}`);\n          console.log(err.toString());\n        }\n      }\n    }\n  }\n\n  const tagStack: TagInfo[] = [];\n  let textBuf = \"\";\n\n  function flushTextBuf(): void {\n    if (textBuf !== \"\") {\n      fireEvent(\"text\", [textBuf]);\n      textBuf = \"\";\n    }\n  }\n\n  parser.onopentag = (node: SaxesTag) => {\n    flushTextBuf();\n    const names = Object.keys(node.attributes);\n    const nsDefinitions = [];\n    const attributeEvents = [];\n    names.sort();\n    for (const name of names) {\n      const attr = node.attributes[name] as SaxesAttribute;\n      if (name === \"xmlns\") { // xmlns=\"...\"\n        nsDefinitions.push([\"\", attr.value]);\n      }\n      else if (attr.prefix === \"xmlns\") { // xmlns:...=...\n        nsDefinitions.push([attr.local, attr.value]);\n      }\n      else {\n        attributeEvents.push([\"attributeName\", attr.uri, attr.local],\n                             [\"attributeValue\", attr.value]);\n      }\n    }\n    if (nsDefinitions.length !== 0) {\n      nameResolver.enterContext();\n      for (const definition of nsDefinitions) {\n        nameResolver.definePrefix(definition[0], definition[1]);\n      }\n    }\n    fireEvent(\"enterStartTag\", [node.uri, node.local]);\n    for (const event of attributeEvents) {\n      fireEvent(event[0], event.slice(1));\n    }\n    fireEvent(\"leaveStartTag\", []);\n    tagStack.push({\n      uri: node.uri,\n      local: node.local,\n      hasContext: nsDefinitions.length !== 0,\n    });\n  };\n\n  parser.ontext = (text: string) => {\n    textBuf += text;\n  };\n\n  parser.onclosetag = () => {\n    flushTextBuf();\n    const tagInfo = tagStack.pop();\n    if (tagInfo === undefined) {\n      throw new Error(\"stack underflow\");\n    }\n    fireEvent(\"endTag\", [tagInfo.uri, tagInfo.local]);\n    if (tagInfo.hasContext) {\n      nameResolver.leaveContext();\n    }\n  };\n\n  const entityRe = /^<!ENTITY\\s+([^\\s]+)\\s+(['\"])(.*?)\\2\\s*>\\s*/;\n\n  parser.ondoctype = (doctype: string) => {\n    // This is an extremely primitive way to handle ENTITY declarations in a\n    // DOCTYPE. It is unlikely to support any kind of complicated construct.\n    // If a reminder need be given then: THIS PARSER IS NOT MEANT TO BE A\n    // GENERAL SOLUTION TO PARSING XML FILES!!! It supports just enough to\n    // perform some testing.\n    let cleaned = doctype\n      .replace(/^.*?\\[/, \"\")\n      .replace(/].*?$/, \"\")\n      .replace(/<!--(?:.|\\n|\\r)*?-->/g, \"\")\n      .trim();\n\n    while (cleaned.length !== 0) {\n      const match = entityRe.exec(cleaned);\n      if (match !== null) {\n        const name = match[1];\n        const value = match[3];\n        cleaned = cleaned.slice(match[0].length);\n        if (parser.ENTITIES[name] !== undefined) {\n          throw new Error(`redefining entity: ${name}`);\n        }\n        parser.ENTITIES[name] = value;\n      }\n      else {\n        throw new Error(`unexpected construct in DOCTYPE: ${doctype}`);\n      }\n    }\n\n    console.log(doctype);\n  };\n\n  parser.onend = () => {\n    const result = walker.end();\n    if (result !== false) {\n      error = true;\n      if (!mute) {\n        for (const err of result) {\n          console.log(`on end`);\n          console.log(err.toString());\n        }\n      }\n    }\n  };\n\n  parser.write(xmlSource).close();\n\n  return error;\n}\n\n//  LocalWords:  doctype DOCTYPE leaveContext definePrefix enterContext ev MPL\n//  LocalWords:  enterStartTag leaveStartTag endTag attributeValue xmlns\n//  LocalWords:  attributeName namespace\n"]}