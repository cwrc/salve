{"version":3,"file":"name_patterns.js","sourceRoot":"","sources":["../../../../lib/salve/name_patterns.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nfunction escapeString(str: string): string {\n  return str.replace(/([\"\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Base class for all name patterns.\n */\nexport abstract class Base {\n  abstract readonly kind: string;\n\n  private _asString?: string;\n\n  /**\n   * Tests whether the pattern matches a name.\n   *\n   * @param ns The namespace to match.\n   * @param name The name to match.\n   * @returns ``true`` if there is a match.\n   */\n  abstract match(ns: string, name: string): boolean;\n\n  /**\n   * Test whether a pattern intersects another pattern. Two pattern intersect if\n   * there exist a name that can be matched by both.\n   *\n   * @param other The other pattern to check.\n   */\n  abstract intersects(other: ConcreteName): boolean;\n\n  /**\n   * Computes the intersection of two patterns.\n   *\n   * @param other The other pattern to check.\n   *\n   * @returns 0 if the intersection is the empty set. Otherwise, a ConcreteName\n   * representing the intersection.\n   */\n  abstract intersection(other: ConcreteName | 0): ConcreteName | 0;\n\n  /**\n   * Tests whether the pattern matches a name and this match is due only to a\n   * wildcard match (``nsName`` or ``anyName``).\n   *\n   * @param ns The namespace to match.\n   * @param name The name to match.\n   *\n   * @returns ``true`` if there is a match **and** the match is due only to a\n   * wildcard match. If there is a choice between matching with a wildcard and\n   * matching with a regular ``name`` pattern, this will return false because of\n   * the ``name`` pattern.\n   */\n  abstract wildcardMatch(ns: string, name: string): boolean;\n\n  /**\n   * Determines whether a pattern is simple or not. A pattern is deemed simple\n   * if it does not use ``<except>``, ``<anyName>`` or ``<NsName>``.  Put in\n   * practical terms, non-simple patterns cannot generally be presented as a\n   * list of choices to the user. In most cases, the appropriate input from the\n   * user should be obtained by presenting an input field in which the user can\n   * type the namespace and name of the entity to be named and the GUI reports\n   * whether the name is allowed or not by the schema.\n   *\n   * @returns  ``true`` if the pattern is simple.\n   */\n  abstract simple(): boolean;\n\n  /**\n   * Gets the list of namespaces used in the pattern. An ``::except`` entry\n   * indicates that there are exceptions in the pattern. A ``*`` entry indicates\n   * that any namespace is allowed.\n   *\n   * This method should be used by client code to help determine how to prompt\n   * the user for a namespace. If the return value is a list without\n   * ``::except`` or ``*``, the client code knows there is a finite list of\n   * namespaces expected, and what the possible values are. So it could present\n   * the user with a choice from the set. If ``::except`` or ``*`` appears in\n   * the list, then a different strategy must be used.\n   *\n   * @returns The list of namespaces.\n   */\n  getNamespaces(): string[] {\n    const namespaces: Set<string> = new Set();\n    this._recordNamespaces(namespaces, true);\n\n    return Array.from(namespaces);\n  }\n\n  /**\n   * This is public due to limitations in how TypeScript works. You should never\n   * call this function directly.\n   *\n   * @param namespaces A map in which to record namespaces.\n   *\n   * @param recordEmpty Whether to record an empty namespace in the map.\n   */\n  abstract _recordNamespaces(namespaces: Set<string>,\n                             recordEmpty: boolean): void;\n\n  /**\n   * Represent the name pattern as a plain object. The object returned contains\n   * a ``pattern`` field which has the name of the JavaScript class that was\n   * used to create the object. Other fields are present, depending on the\n   * actual needs of the class.\n   *\n   * @returns The object representing the instance.\n   */\n  abstract toObject(): any;\n\n  /**\n   * Alias of [[Base.toObject]].\n   *\n   * ``toJSON`` is a misnomer, as the data returned is not JSON but a JavaScript\n   * object. This method exists so that ``JSON.stringify`` can use it.\n   */\n  toJSON(): any {\n    return this.toObject();\n  }\n\n  /**\n   * Returns an array of [[Name]] objects which is a list of all\n   * the possible names that this pattern allows.\n   *\n   * @returns An array of names. The value ``null`` is returned if the pattern\n   * is not simple.\n   */\n  abstract toArray(): Name[] | null;\n\n  /**\n   * Stringify the pattern to a JSON string.\n   *\n   * @returns The stringified instance.\n   */\n  toString(): string {\n    // Profiling showed that caching the string representation helps\n    // performance.\n    if (this._asString === undefined) {\n      this._asString = this.asString();\n    }\n\n    return this._asString;\n  }\n\n  protected abstract asString(): string;\n}\n\nexport type ConcreteName = Name | NameChoice | NsName | AnyName;\n\nexport function isName(name: ConcreteName): name is Name {\n  return name.kind === \"Name\";\n}\n\nexport function isNameChoice(name: ConcreteName): name is NameChoice {\n  return name.kind === \"NameChoice\";\n}\n\nexport function isNsName(name: ConcreteName): name is NsName {\n  return name.kind === \"NsName\";\n}\n\nexport function isAnyName(name: ConcreteName): name is AnyName {\n  return name.kind === \"AnyName\";\n}\n\n/**\n * Models the Relax NG ``<name>`` element.\n *\n */\nexport class Name extends Base {\n  readonly kind: \"Name\" = \"Name\";\n\n  /**\n   * @param ns The namespace URI for this name. Corresponds to the\n   * ``ns`` attribute in the simplified Relax NG syntax.\n   *\n   * @param name The name. Corresponds to the content of ``<name>``\n   * in the simplified Relax NG syntax.\n   *\n   * @param documentation Attached documentation if available.\n   */\n  constructor(readonly ns: string, readonly name: string,\n              readonly documentation?: string) {\n    super();\n  }\n\n  match(ns: string, name: string): boolean {\n    return this.name === name && this.ns === ns;\n  }\n\n  intersects(other: ConcreteName): boolean {\n    return isName(other) ? this.match(other.ns, other.name) :\n      // Delegate to the other classes.\n      other.intersects(this);\n  }\n\n  intersection(other: ConcreteName | 0): ConcreteName | 0 {\n    if (other === 0) {\n      return 0;\n    }\n\n    if (isName(other)) {\n      return this.match(other.ns, other.name) ? this : 0;\n    }\n\n    // Delegate to the other classes.\n    return other.intersection(this);\n  }\n\n  // @ts-ignore\n  wildcardMatch(ns: string, name: string): false {\n    return false; // This is not a wildcard.\n  }\n\n  toObject(): { ns: string; name: string; documentation: string | undefined } {\n    return {\n      ns: this.ns,\n      name: this.name,\n      documentation: this.documentation,\n    };\n  }\n\n  asString(): string {\n    // We don't need to escape this.name because names cannot contain\n    // things that need escaping.\n    const doc = this.documentation ?\n      `,\"documentation\":\"${this.documentation}\"` : \"\";\n    return `{\"ns\":\"${escapeString(this.ns)}\",\"name\":\"${this.name}\"${doc}}`;\n  }\n\n  simple(): true {\n    return true;\n  }\n\n  toArray(): Name[] {\n    return [this];\n  }\n\n  _recordNamespaces(namespaces: Set<string>, recordEmpty: boolean): void {\n    if (this.ns === \"\" && !recordEmpty) {\n      return;\n    }\n\n    namespaces.add(this.ns);\n  }\n}\n\n/**\n * Models the Relax NG ``<choice>`` element when it appears in a name\n * class.\n */\nexport class NameChoice extends Base {\n  readonly kind: \"NameChoice\" = \"NameChoice\";\n\n  /**\n   * @param a The first choice.\n   *\n   * @param b The second choice.\n   */\n  constructor(readonly a: ConcreteName, readonly b: ConcreteName) {\n    super();\n  }\n\n  /**\n   * Makes a tree of NameChoice objects out of a list of names.\n   *\n   * @param names The names from which to build a tree.\n   *\n   * @return If the list is a single name, then just that name. Otherwise,\n   * the names from the list in a tree of [[NameChoice]].\n   */\n  static makeTree(names: ConcreteName[]): ConcreteName {\n    if (names.length === 0) {\n      throw new Error(\"trying to make a tree out of nothing\");\n    }\n\n    let ret: ConcreteName;\n    if (names.length > 1) {\n      // More than one name left. Convert them to a tree.\n      let top = new NameChoice(names[0], names[1]);\n      for (let ix = 2; ix < names.length; ix++) {\n        top = new NameChoice(top, names[ix]);\n      }\n\n      ret = top;\n    }\n    else {\n      // Only one name: we can use it as-is.\n      ret = names[0];\n    }\n\n    return ret;\n  }\n\n  match(ns: string, name: string): boolean {\n    return this.a.match(ns, name) || this.b.match(ns, name);\n  }\n\n  intersects(other: ConcreteName): boolean {\n    return this.a.intersects(other) || this.b.intersects(other);\n  }\n\n  intersection(other: ConcreteName | 0): ConcreteName | 0 {\n    if (other === 0) {\n      return 0;\n    }\n\n    const a = this.a.intersection(other);\n    const b = this.b.intersection(other);\n\n    return a === 0 ? b : (b === 0 ? a : new NameChoice(a, b));\n  }\n\n  /**\n   * Recursively apply a transformation to a NameChoice tree.\n   *\n   * @param fn The transformation to apply. It may return 0 to indicate that the\n   * child has been transformed to the empty set.\n   *\n   * @returns The transformed tree, or 0 if the tree has been transformed to\n   * nothing.\n   */\n  applyRecursively(fn: (child: Name | NsName | AnyName) => ConcreteName | 0):\n  ConcreteName | 0 {\n    const { a, b } = this;\n    const newA = isNameChoice(a) ? a.applyRecursively(fn) : fn(a);\n    const newB = isNameChoice(b) ? b.applyRecursively(fn) : fn(b);\n\n    return newA === 0 ? newB :\n      (newB === 0 ? newA : new NameChoice(newA, newB));\n  }\n\n  wildcardMatch(ns: string, name: string): boolean {\n    return this.a.wildcardMatch(ns, name) || this.b.wildcardMatch(ns, name);\n  }\n\n  toObject(): { a: any; b: any } {\n    return {\n      a: this.a.toObject(),\n      b: this.b.toObject(),\n    };\n  }\n\n  asString(): string {\n    return `{\"a\":${this.a.toString()},\"b\":${this.b.toString()}}`;\n  }\n\n  simple(): boolean {\n    return this.a.simple() && this.b.simple();\n  }\n\n  toArray(): Name[] | null {\n    const aArr = this.a.toArray();\n    if (aArr === null) {\n      return null;\n    }\n\n    const bArr = this.b.toArray();\n    return bArr === null ? null : aArr.concat(bArr);\n  }\n\n  _recordNamespaces(namespaces: Set<string>, recordEmpty: boolean): void {\n    this.a._recordNamespaces(namespaces, recordEmpty);\n    this.b._recordNamespaces(namespaces, recordEmpty);\n  }\n}\n\n/**\n * Models the Relax NG ``<nsName>`` element.\n */\nexport class NsName extends Base {\n  readonly kind: \"NsName\" = \"NsName\";\n\n  /**\n   * @param ns The namespace URI for this name. Corresponds to the ``ns``\n   * attribute in the simplified Relax NG syntax.\n   *\n   * @param except Corresponds to an ``<except>`` element appearing as a child\n   * of the ``<nsName>`` element in the Relax NG schema.\n   */\n  constructor(readonly ns: string, readonly except?: ConcreteName) {\n    super();\n  }\n\n  match(ns: string, name: string): boolean {\n    return this.ns === ns && !(this.except !== undefined &&\n                               this.except.match(ns, name));\n  }\n\n  intersects(other: ConcreteName): boolean {\n    if (isName(other)) {\n      return this.ns === other.ns &&\n        (this.except === undefined || !other.intersects(this.except));\n    }\n\n    return isNsName(other) ? this.ns === other.ns :\n      // Delegate the logic to the other classes.\n      other.intersects(this);\n  }\n\n  intersection(other: ConcreteName | 0): ConcreteName | 0 {\n    if (other === 0) {\n      return 0;\n    }\n\n    if (isName(other)) {\n      if (this.ns !== other.ns) {\n        return 0;\n      }\n\n      if (this.except !== undefined) {\n        // We're computing other - other ^ this.except\n        //\n        // Since other is a single name, there are only two possible values for\n        // other ^ this.except: other and 0.\n        //\n        // Consequently the whole equation can also only resolve to other and 0.\n        return other.intersection(this.except) === 0 ? other : 0;\n      }\n\n      return other;\n    }\n\n    if (isNsName(other)) {\n      if (this.ns !== other.ns) {\n        return 0;\n      }\n\n      if (this.except !== undefined && other.except !== undefined) {\n        // We have to create a new except that does not duplicate exceptions.\n        // For instance if this excepts {q}foo and other excepts {q}foo too, we\n        // don't want to have an exception that has {q}foo twice.\n\n        // Due to Relax NG restrictions on NsName, both excepts necessarily\n        // contain only Name or NameChoice elements.\n        const theseNames = this.except.toArray();\n        const otherNames = other.except.toArray();\n\n        // And so these cannot be null.\n        if (theseNames === null || otherNames === null) {\n          throw new Error(\"complex pattern found in NsName except\");\n        }\n\n        // Find the unique names.\n        const names =\n          Array.from(new Map<string, Name>(\n            theseNames.concat(otherNames)\n              .map(name => [`{${name.ns}}${name.name}`, name])).values());\n\n        return new NsName(this.ns, NameChoice.makeTree(names));\n      }\n\n      return (other.except !== undefined) ? other : this;\n    }\n\n    // Delegate the logic to the other classes.\n    return other.intersection(this);\n  }\n\n  /**\n   * Subtract a [[Name]] or [[NsName]] from this one, or a [[NameChoice]] that\n   * contains only a mix of these two. We support subtracting only these two\n   * types because only these two cases are required by Relax NG.\n   *\n   * @param other The object to subtract from this one.\n   *\n   * @returns An object that represents the subtraction. If the result is the\n   * empty set, 0 is returned.\n   */\n  subtract(other: Name | NsName | NameChoice): ConcreteName | 0 {\n    if (isNameChoice(other)) {\n      // x - (a U b) = x - a U x - b\n      return other.applyRecursively(child => {\n        if (!(isName(child) || isNsName(child))) {\n          throw new Error(\"child is not Name or NsName\");\n        }\n\n        return this.subtract(child);\n      });\n    }\n\n    if (this.ns !== other.ns) {\n      return this;\n    }\n\n    if (isName(other)) {\n      return new NsName(this.ns,\n                        this.except === undefined ?\n                        other :\n                        new NameChoice(this.except, other));\n    }\n\n    if (other.except === undefined) {\n      return 0;\n    }\n\n    if (this.except === undefined) {\n      return other.except;\n    }\n\n    // Otherwise, return other.except - this.except. Yes, the order is\n    // correct.\n\n    // Due to Relax NG restrictions on NsName, both excepts may contain only\n    // Name or NameChoice, so only simple patterns that can be converted to\n    // arrays.\n    const theseNames = this.except.toArray();\n    const otherNames = other.except.toArray();\n\n    if (theseNames === null || otherNames === null) {\n      throw new Error(\"NsName contains an except pattern which is not simple.\");\n    }\n\n    const result = otherNames\n      .filter(name => !theseNames.some(thisName => name.ns === thisName.ns &&\n                                       name.name === thisName.name));\n\n    return result.length === 0 ? 0 : NameChoice.makeTree(result);\n  }\n\n  wildcardMatch(ns: string, name: string): boolean {\n    return this.match(ns, name);\n  }\n\n  toObject(): { ns: string; except?: any } {\n    const ret: { ns: string; except?: any } = {\n      ns: this.ns,\n    };\n    if (this.except !== undefined) {\n      ret.except = this.except.toObject();\n    }\n\n    return ret;\n  }\n\n  asString(): string {\n    const except = this.except === undefined ? \"\" :\n      `,\"except\":${this.except.toString()}`;\n\n    return `{\"ns\":\"${escapeString(this.ns)}\"${except}}`;\n  }\n\n  simple(): false {\n    return false;\n  }\n\n  toArray(): null {\n    return null;\n  }\n\n  _recordNamespaces(namespaces: Set<string>, recordEmpty: boolean): void {\n    if (this.ns !== \"\" || recordEmpty) {\n      namespaces.add(this.ns);\n    }\n\n    if (this.except !== undefined) {\n      namespaces.add(\"::except\");\n    }\n  }\n}\n\n/**\n * Models the Relax NG ``<anyName>`` element.\n */\nexport class AnyName extends Base {\n  readonly kind: \"AnyName\" = \"AnyName\";\n\n  /**\n   * @param except Corresponds to an ``<except>`` element appearing as a child\n   * of the ``<anyName>`` element in the Relax NG schema.\n   */\n  constructor(readonly except?: ConcreteName) {\n    super();\n  }\n\n  match(ns: string, name: string): boolean {\n    return (this.except === undefined) || !this.except.match(ns, name);\n  }\n\n  intersects(other: ConcreteName): boolean {\n    if (this.except === undefined || isAnyName(other)) {\n      return true;\n    }\n\n    if (isName(other)) {\n      return !this.except.intersects(other);\n    }\n\n    if (isNsName(other)) {\n      // Reminder: the except can only be one of three things: Name, NsName or\n      // NameChoice so negation can only be 0, Name, NsName or NameChoice.\n      const negation = this.except.intersection(other);\n\n      //\n      // We've commented out this test. The simplification/validation/checking\n      // logic prevents us from failing this test.\n      //\n      // if (!(negation === 0 || isName(negation) || isNsName(negation) ||\n      //       isNameChoice(negation))) {\n      //   throw new Error(\"negation should be 0, Name, NsName or NameChoice\");\n      // }\n      //\n\n      // In the absence of the test above, we must assert the type of negation\n      // here.\n      return negation === 0 ||\n        other.subtract(negation as Name | NsName | NameChoice) !== 0;\n    }\n\n    throw new Error(\"cannot compute intersection!\");\n  }\n\n  intersection(other: ConcreteName | 0): ConcreteName | 0 {\n    if (other === 0) {\n      return 0;\n    }\n\n    if (this.except === undefined) {\n      return other;\n    }\n\n    if (isName(other)) {\n      return this.except.intersection(other) === 0 ? other : 0;\n    }\n\n    if (isNsName(other)) {\n      // Reminder: the except can only be one of three things: Name, NsName or\n      // NameChoice so negation can only be 0, Name, NsName or NameChoice.\n      const negation = this.except.intersection(other);\n      //\n      // We've commented out this test. The simplification/validation/checking\n      // logic prevents us from failing this test.\n      //\n      // if (!(negation === 0 || isName(negation) || isNsName(negation) ||\n      //       isNameChoice(negation))) {\n      //   throw new Error(\"negation should be 0, Name, NsName or NameChoice\");\n      // }\n      //\n\n      // In the absence of the test above, we must assert the type of negation\n      // here.\n      return negation === 0 ? other :\n        other.subtract(negation  as Name | NsName | NameChoice);\n    }\n\n    if (isAnyName(other)) {\n      if (other.except !== undefined && this.except !== undefined) {\n        return new AnyName(new NameChoice(this.except, other.except));\n      }\n\n      return (other.except !== undefined) ? other : this;\n    }\n\n    throw new Error(\"cannot compute intersection!\");\n  }\n\n  wildcardMatch(ns: string, name: string): boolean {\n    return this.match(ns, name);\n  }\n\n  toObject(): { pattern: \"AnyName\"; except?: any } {\n    const ret: { pattern: \"AnyName\"; except?: any } = {\n      pattern: \"AnyName\",\n    };\n    if (this.except !== undefined) {\n      ret.except = this.except.toObject();\n    }\n\n    return ret;\n  }\n\n  asString(): string {\n    const except = this.except === undefined ? \"\" :\n      `,\"except\":${this.except.toString()}`;\n\n    return `{\"pattern\":\"AnyName\"${except}}`;\n  }\n\n  simple(): false {\n    return false;\n  }\n\n  toArray(): null {\n    return null;\n  }\n\n  _recordNamespaces(namespaces: Set<string>, _recordEmpty: boolean): void {\n    namespaces.add(\"*\");\n    if (this.except !== undefined) {\n      namespaces.add(\"::except\");\n    }\n  }\n}\n\n//  LocalWords:  MPL NG Stringify stringified AnyName\n"]}